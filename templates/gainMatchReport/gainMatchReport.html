<link rel="stylesheet" href="gainMatchReport.css"/>

<template id='gainMatchReport'>
    <div class='sectionWrapper item'>
        <div class='col-md-12'>
            <table id='{{id}}gainMatchingResults' class='table gainTable'></table>

            <button type="button" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myAnalyzerModal">
                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write calibration to Analyzer
            </button>
<br>
            <button type="button" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myODBModal">
                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write calibration to ODB
            </button>
<br>
            <button type="button" class="btn btn-primary btn-lg"  id='saveCal'>
                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Save Cal file
            </button>
	    <input id='saveCalname' type='text' value='GRIFFIN-Cal-File.cal' size='48'></input>

        </div>
    </div>

    <!--are you sure modal for Analyzer write-->
    <div class="modal fade" id="myAnalyzerModal" tabindex="-1" role="dialog" aria-labelledby="myAnalyzerModalLabel">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                    <h4 class="modal-title" id="myAnalyzerModalLabel">Change values in Analyzer Config file?</h4>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to change the quadratic, gain and offset values for all selected detectors in the Analyzer? There is no undo.</p>
                    <input type='checkbox' id='{{id}}yesDefinitelyWriteAnalyzer'></input>
                    <label for='{{id}}yesDefinitelyWriteAnalyzer'>I'm very sure.</label>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal" id='dismissAnalyzermodal'>
                        <span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span> Abort
                    </button>
                    <button type="button" class="btn btn-default" id='{{id}}writeToAnalyzer' disabled>
                        <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!--are you sure modal for ODB write-->
    <div class="modal fade" id="myODBModal" tabindex="-1" role="dialog" aria-labelledby="myODBModalLabel">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                    <h4 class="modal-title" id="myODBModalLabel">Change values in ODB?</h4>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to change the quadratic, gain and offset values for all selected detectors in the ODB? There is no undo.</p>
                    <input type='checkbox' id='{{id}}yesDefinitelyWriteODB'></input>
                    <label for='{{id}}yesDefinitelyWriteODB'>I'm very sure.</label>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal" id='dismissODBmodal'>
                        <span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span> Abort
                    </button>
                    <button type="button" class="btn btn-default" id='{{id}}writeToODB' disabled>
                        <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write
                    </button>
                </div>
            </div>
        </div>
    </div>
</template>

<script>
    function gainMatchReport(wrapID, setupWrapID){

        this.wrapID = wrapID;
        this.setupWrapID = setupWrapID;
        this.wrap = document.getElementById(wrapID);
        this.setupWrap = document.getElementById(setupWrapID)

    this.setup = function(){

            // build list of source titles
    var listOfSourceTitles = [];
      for(var i=0; i<dataStore.sourceInfo[dataStore.detectorType].length; i++){
        var thisObject = {
          "name" : dataStore.sourceInfo[dataStore.detectorType][i].name,
          "title" : dataStore.sourceInfo[dataStore.detectorType][i].title
        }
        listOfSourceTitles.push(thisObject);
      }

            //inject templates
            this.setupWrap.innerHTML = Mustache.to_html(
                dataStore.templates.gainMatchSetupBar,
                {
                    'id': this.setupWrapID,
                    'sourceTitle': listOfSourceTitles
                }
            );

            this.wrap.innerHTML = Mustache.to_html(
                dataStore.templates.gainMatchReport,
                {
                    'id': this.wrapID,
                }
            );
            // table has to be done as a separate template, since templates and tables don't play too nice together
            document.getElementById(this.wrapID + 'gainMatchingResults').innerHTML= Mustache.to_html(
                dataStore.templates.matchReportTable,
                {
                    'id': this.wrapID,
                    'detectors': dataStore.THESEdetectors
                }
            );

            //plug in fit all button
            document.getElementById('fitAll').onclick = this.fitAll.bind(this);
            document.getElementById('fitAll').removeAttribute('disabled');

            //plug in calibration source dropdown
            document.getElementById('gainMatchercalibrationSource').onchange = this.updateEnergies.bind(this);

            //plug in peak energy inputs
            document.getElementById('peak1').onchange = this.customEnergy.bind(this);
            document.getElementById('peak2').onchange = this.customEnergy.bind(this);
            document.getElementById('peak3').onchange = this.customEnergy.bind(this);
            document.getElementById('peak4').onchange = this.customEnergy.bind(this);

            // plug in onclick functions to the spectrum name cells
            for(var i=0; i<dataStore.THESEdetectors.length; i++){
              thisSpectrum = dataStore.THESEdetectors[i] + '_Pulse_Height';
              document.getElementById(this.wrapID + dataStore.THESEdetectors[i] + 'name').onclick = function(){
              var plot = this.innerHTML + '_Pulse_Height';
              if(dataStore.histoFileName.length>0){
                plot = dataStore.histoFileName.split('.')[0] + ':' + plot;
              }
              dataStore._plotListLite.exclusivePlot(plot, dataStore.viewers[dataStore.plots[0]]);
              document.body.scrollTop = document.documentElement.scrollTop = 0;
             }
            }

            //plug in write to odb toggles
            document.getElementById('writeAllChannels').onchange = this.toggleAllODBWrites.bind(this);

            //make sure the file name for Cal file download gets passed around:
             document.getElementById('saveCalname').onchange = function(){
            //set the filename to whatever the user has requested:
             document.getElementById('saveCal').download = this.value;
            }

            // Set up the Cal file button
            document.getElementById('saveCal').onclick = function(){ buildCalfile(); }

            //set up fit callbacks
            dataStore.viewers[dataStore.plots[0]].fitCallback = this.fitCallback.bind(this);

            //plug in the allow Analyzer write switch
            document.getElementById(this.wrapID + 'yesDefinitelyWriteAnalyzer').onchange = this.toggleAnalyzerwrite.bind(this);

            //plug in write to Analyzer button
            document.getElementById(this.wrapID + 'writeToAnalyzer').onclick = function(){
                //bail out if there's no fit yet
                if(Object.keys(dataStore.fitResults).length == 0){
                    window.alert('You need to perform the gain match (see button at top of page) before writing results to the Analyzer.');
                    document.getElementById('dismissAnalyzermodal').click();
                }
                updateAnalyzer();
            }

            //plug in the allow ODB write switch
            document.getElementById(this.wrapID + 'yesDefinitelyWriteODB').onchange = this.toggleODBwrite.bind(this);

            //plug in write to odb button
            document.getElementById(this.wrapID + 'writeToODB').onclick = function(){
                //bail out if there's no fit yet
                if(Object.keys(dataStore.fitResults).length == 0){
                    window.alert('You need to perform the gain match (see button at top of page) before writing results to the ODB.');
                    document.getElementById('dismissODBmodal').click();
                }
                promiseScript(dataStore.ODBrequests[0]);
            }
        },

        this.fitAll = function(){
            //fit all spectra to the peaks defined.
//this: gainMatchReport object

            var i, keys = Object.keys(dataStore.rawData),
                buffer = dataStore.currentPlot //keep track of whatever was originally plotted so we can return to it

            releaser(
                function(i){
                    var keys = Object.keys(dataStore.rawData);
                    this.fitSpectra(keys[i])
                    document.getElementById('progress').setAttribute('style', 'width:' + (100*(keys.length - i) / keys.length) + '%' )
                }.bind(this),

                function(){
                    var evt;
                    //set up fit line re-drawing
                    dataStore.viewers[dataStore.plots[0]].drawCallback = this.addFitLines;

                    //comunicate with the user
                    if(document.getElementById('pickerMessage')){ deleteNode('pickerMessage') }
                    document.getElementById('reviewMessage').classList.remove('hidden');

                    //leave the viewer pointing at the first spectrum for fitting
                    dispatcher({target: buffer}, 'fitAllComplete')

                    //highlight suspicious rows
                    this.whatsNormal();
                    this.highlightOutliers();

                    console.log(dataStore);
                }.bind(this),

                keys.length-1
            )
        },

        this.fitSpectra = function(spectrum){
            //redo the fits for the named spectrum.
            //<spectrum>: string; name of spectrum, per names from analyzer
            //this: gainMatchReport object

            var viewerName = dataStore.plots[0];

            //identify regions of interest
            this.guessPeaks(spectrum, dataStore.rawData[spectrum]);

                //set up fitting
                dataStore.viewers[viewerName].addData(spectrum, JSON.parse(JSON.stringify(dataStore.rawData[spectrum])) );
                dataStore.currentPlot = spectrum;
                dataStore.viewers[viewerName].plotData() //kludge to update limits, could be nicer
                dataStore.viewers[viewerName].fitTarget = spectrum;

                //fit each peak
                var index = dataStore.sourceInfo[dataStore.detectorType].map(function(e) { return e.name; }).indexOf(dataStore.sourceType);
                for(var peakIndex=0; peakIndex<dataStore.sourceInfo[dataStore.detectorType][index].energies.length; peakIndex++){
                dataStore.currentPeak = peakIndex;
                dataStore.viewers[viewerName].FitLimitLower = dataStore.ROI[spectrum][peakIndex][0];
                dataStore.viewers[viewerName].FitLimitUpper = dataStore.ROI[spectrum][peakIndex][1];
                dataStore.viewers[viewerName].fitData(spectrum, 0);
                }

                //dump data so it doesn't stack up
                dataStore.viewers[viewerName].removeData(spectrum);


        },

        this.addFitLines = function(){
            //add current fits to the plot

            var fitLines = [];
            var viewerName = dataStore.plots[0];

            dataStore.viewers[viewerName].containerFit.removeAllChildren();
            //add fit lines
            var index = dataStore.sourceInfo[dataStore.detectorType].map(function(e) { return e.name; }).indexOf(dataStore.sourceType);
            for(i=0; i<dataStore.sourceInfo[dataStore.detectorType][index].energies.length; i++){

              thisFitLine = dataStore.viewers[viewerName].addFitLine(
                          dataStore.ROI[dataStore.currentPlot][i][0],
                          dataStore.ROI[dataStore.currentPlot][i][1] - dataStore.ROI[dataStore.currentPlot][i][0],
                          dataStore.fitResults[dataStore.currentPlot][i][0],
                          dataStore.fitResults[dataStore.currentPlot][i][1],
                          dataStore.fitResults[dataStore.currentPlot][i][2],
                          dataStore.fitResults[dataStore.currentPlot][i][3],
                          dataStore.fitResults[dataStore.currentPlot][i][4]
                      );
              dataStore.viewers[viewerName].containerFit.addChild(thisFitLine);
            }

            dataStore.viewers[viewerName].stage.update();
        },

        this.guessPeaks = function(spectrumName, data){
          //given a spectrum <data>, identify the bins corresponding to the maxima of the two largest peaks.
          //register a range around those peaks as our automated guesses for where the gammas of interest lie.
          //<spectrumName>: string; name of spectrum, per names from analyzer
          //<data>: array; bin contents for a spectrum, array index == bin number.
          //this: gainMatchReport object

          var lowPeakIndex = parseInt(document.getElementById('peak1position').value,10),
          medPeakIndex = parseInt(document.getElementById('peak2position').value,10),
          highPeakIndex = parseInt(document.getElementById('peak3position').value,10),
          vhiPeakIndex = parseInt(document.getElementById('peak4position').value,10),
          centers = [],
          ROIwidth = 5,
          i,j;
          var sum=0;
          var average=1;
          var foundPeaks = [], foundId = [];
          var thisSearchRegion = [];
          var index = dataStore.sourceInfo[dataStore.detectorType].map(function(e) { return e.name; }).indexOf(dataStore.sourceType);

          // Different detector types have different energy resolution
          if(dataStore.detectorType == 'LaBr3'){
            ROIwidth = 20;
          }else if(dataStore.detectorType == 'RCMP'){ ROIwidth = 50; }

          // Now we have X search regions instead of a single search region
          // identify the peak center of the three highest peaks within the search region for each Peak
          for(thisPeakIndex=0; thisPeakIndex<dataStore.searchRegion.length; thisPeakIndex++){
            foundPeaks[thisPeakIndex] = [];
            searchLength = Math.floor((dataStore.searchRegion[thisPeakIndex][1] - dataStore.searchRegion[thisPeakIndex][0]));
            centers[thisPeakIndex]=1;   foundId[thisPeakIndex]=0;
            thisSearchRegion[0] = dataStore.searchRegion[thisPeakIndex][0];
            thisSearchRegion[1] = dataStore.searchRegion[thisPeakIndex][1];
            while(foundId[thisPeakIndex]<3){
              thisPeak=thisSearchRegion[0];
              for(i=thisSearchRegion[0]; i<(thisSearchRegion[1]); i++){
                if(foundId[thisPeakIndex]>0 && i > (foundPeaks[thisPeakIndex][0]-ROIwidth) && i < (foundPeaks[thisPeakIndex][0]+ROIwidth)){ continue; }
                if(foundId[thisPeakIndex]>1 && i > (foundPeaks[thisPeakIndex][1]-ROIwidth) && i < (foundPeaks[thisPeakIndex][1]+ROIwidth)){ continue; }
                localPBG = (data[i-4]+data[i-3]+data[i-2]+data[i-1]+data[i]+data[i+1]+data[i+2]+data[i+3]) / (data[i-8]+data[i-7]+data[i-6]+data[i-5]+data[i+5]+data[i+6]+data[i+7]+data[i+8]);
                if(data[i] > data[thisPeak] && localPBG>0.5){
                  thisPeak=i;
                }
              }

              if(thisPeak>thisSearchRegion[0]){
                foundPeaks[thisPeakIndex][foundId[thisPeakIndex]]=thisPeak;
                foundId[thisPeakIndex]++;
              }else if(foundId[thisPeakIndex]<1){
                thisSearchRegion[0] += 10;
                if(thisSearchRegion[0]>(thisSearchRegion[1] - 20)){
                  foundId[thisPeakIndex]=3;
                }
              }else{
                foundPeaks[thisPeakIndex][2]=foundPeaks[thisPeakIndex][1]=foundPeaks[thisPeakIndex][0];  foundId[thisPeakIndex]=3;

              }
            }
            centers[thisPeakIndex]=foundPeaks[thisPeakIndex][0];
          }

          // Perform sanity checks on the Guessed peaks here to identify which set is correct.
          // The peak with the highest number of counts might not be the correct peak for the energy we are looking for
          var centers = this.identifyCorrectPeaks(foundPeaks, foundId);

          // Likely a mistake in the literature energies or search regions
          if(centers.length<2){ console.log("Failed to guess peaks correctly"); }

          // Define the Regions of Interest for the full peak fitting based on the peaks found
          if(dataStore.detectorType == 'LaBr3'){
            // Special case for LaBr3 where the resolution deteriorates with energy in a non-linear way (This approach needs improvement)
            //    ROIwidth = (B5*0.012)+9;
            if(typeof(dataStore.ROI[spectrumName]) == 'undefined'){ dataStore.ROI[spectrumName] = []; }
            for(i=0; i<dataStore.sourceInfo[dataStore.detectorType][index].energies.length; i++){
              if(i=0){ROIwidth=10;}
              else if(i=1){ROIwidth=10;}
              else if(i=2){ROIwidth=15;}
              else if(i=3){ROIwidth=30;}
              dataStore.ROI[spectrumName][i] = [centers[i] - 10, centers[i] + 10];
            }
          }else{
            ROIwidth = 4;
              if(dataStore.detectorType == 'RCMP'){ ROIwidth = 80; }

            if(typeof(dataStore.ROI[spectrumName]) == 'undefined'){ dataStore.ROI[spectrumName] = []; }

            for(i=0; i<dataStore.sourceInfo[dataStore.detectorType][index].energies.length; i++){
              dataStore.ROI[spectrumName][i] = [centers[i] - ROIwidth, centers[i] + ROIwidth];
            }
          }

        },

        this.identifyCorrectPeaks = function(foundPeaks, foundId){
          // Perform sanity checks on the Guessed peaks here to identify which set is correct.
          // There are some intense background peaks close by which may be found erroneously
          // First predict and check the position of Peak 1 and 4 based on a linear calibration using only Peak 2 and 3
          var centers = [];
          var NumPeaks = foundPeaks.length;
          var Epeak = [];
          var index = dataStore.sourceInfo[dataStore.detectorType].map(function(e) { return e.name; }).indexOf(dataStore.sourceType);
          for(i=0; i<dataStore.sourceInfo[dataStore.detectorType][index].energies.length; i++){
            Epeak[i] = document.getElementById('peak'+(i+1)).value;
          }

          // Test all combinations of the Peaks identified within the search regions to find the correct set
          var breakForLoop=0;
          for(i=0; i<3; i++){

            for(j=0; j<3; j++){
              if(foundPeaks[1][j]<(foundPeaks[0][i]+5)){ continue; }

              var ratioDiffP12 = Math.abs((foundPeaks[0][i] / foundPeaks[1][j])-(Epeak[0] / Epeak[1]));

              for(k=0; k<3; k++){
                if(foundPeaks[2][k]<(foundPeaks[1][j]+5)){ continue; }
                if(foundPeaks[2][k]<(foundPeaks[0][i]+5)){ continue; }

                var ratioDiffP13 = Math.abs((foundPeaks[0][i] / foundPeaks[2][k])-(Epeak[0] / Epeak[2]));
                var ratioDiffP23 = Math.abs((foundPeaks[1][j] / foundPeaks[2][k])-(Epeak[1] / Epeak[2]));

                if(NumPeaks>3){
                  // Four peaks defined so test consistency with four peaks
                  for(l=0; l<3; l++){
                    if(foundPeaks[3][l]<(foundPeaks[2][k]+5)){ continue; }
                    if(foundPeaks[3][l]<(foundPeaks[1][j]+5)){ continue; }
                    if(foundPeaks[3][l]<(foundPeaks[0][i]+5)){ continue; }

                    var ratioDiffP14 = Math.abs((foundPeaks[0][i] / foundPeaks[3][l])-(Epeak[0] / Epeak[3]));
                    var ratioDiffP24 = Math.abs((foundPeaks[1][j] / foundPeaks[3][l])-(Epeak[1] / Epeak[3]));
                    var ratioDiffP34 = Math.abs((foundPeaks[2][k] / foundPeaks[3][l])-(Epeak[2] / Epeak[3]));

                //    console.log('Test '+i+', '+j+', '+k+', '+l+', '+foundPeaks[0][i]+', '+foundPeaks[1][j]+', '+foundPeaks[2][k]+', '+foundPeaks[3][l]);
                //    console.log('Ratio12='+ratioDiffP12);
                //    console.log('Ratio13='+ratioDiffP13);
                //    console.log('Ratio14='+ratioDiffP14);
                //    console.log('Ratio23='+ratioDiffP23);
              //      console.log('Ratio24='+ratioDiffP24);
              //      console.log('Ratio34='+ratioDiffP34);

                    // Test if this combination of Peaks identified are correct
                    if((ratioDiffP12 < 0.005)
                    && (ratioDiffP13 < 0.005)
                    && (ratioDiffP14 < 0.005)
                    && (ratioDiffP23 < 0.005)
                    && (ratioDiffP24 < 0.005)
                    && (ratioDiffP34 < 0.005)
                    ){
                      centers[0] = foundPeaks[0][i];
                      centers[1] = foundPeaks[1][j];
                      centers[2] = foundPeaks[2][k];
                      centers[3] = foundPeaks[3][l];
                      breakForLoop=1;
                    }
                    if(breakForLoop){ break; }
                  }//end of l for

                }else{
                  // Only three peaks defined so test consistency with three peaks only
                  // Test if this combination of Peaks identified are correct
                  if((ratioDiffP12 < 0.005)
                  && (ratioDiffP13 < 0.005)
                  && (ratioDiffP23 < 0.005)
                  ){
                    centers[0] = foundPeaks[0][i];
                    centers[1] = foundPeaks[1][j];
                    centers[2] = foundPeaks[2][k];
                    breakForLoop=1;
                  }
                }

                if(breakForLoop){ break; }
              }//end of k for
              if(breakForLoop){ break; }
            }//end of j for
            if(breakForLoop){ break; }
          }//end of i for

          return(centers);
        },

        this.fitCallback = function(center, width, amplitude, intercept, slope){
            //after fitting, log the fit results, as well as any modification made to the ROI by the fitting algortihm
            //also update table
            //<center>: number; center of gaussian peak
            //<width>: number; width of peak
            //<amplitude>: number; amplitude of peak
            //<intercept>: number; intercept of linear background beneath peak
            //<slope>: number; slope of linear background
            //this: gainMatchReport object

/*
            var index = dataStore.sourceInfo[dataStore.detectorType].map(function(e) { return e.name; }).indexOf(dataStore.sourceType);
            dataStore.sourceInfo[dataStore.detectorType][dataStore.sourceInfo[dataStore.detectorType].map(function(e) { return e.name; }).indexOf(dataStore.sourceType)].energies.length
            for(i=0; i<dataStore.sourceInfo[dataStore.detectorType][index].energies.length; i++){
              peakButton[i] = document.getElementById('refitButtonP'+(i+1)).value;
            }
            */
            var lowPeak = document.getElementById('fitLow');
            var midPeak = document.getElementById('fitMid');
            var highPeak = document.getElementById('fitHigh');
            var vhiPeak = document.getElementById('fitvHi');
            var viewerName = dataStore.plots[0];
            var thisPlotName = dataStore.currentPlot;
            if(thisPlotName.includes(':')){
               thisPlotName = thisPlotName.split(':')[1].slice(0,10);
            }else{
               thisPlotName = thisPlotName.slice(0,10);
            }

            if(!dataStore.fitResults[dataStore.currentPlot])
                dataStore.fitResults[dataStore.currentPlot] = [];

            //keep track of fit results
            dataStore.fitResults[dataStore.currentPlot][dataStore.currentPeak] = [amplitude, center, width, intercept, slope]

            //convenient to arrange resolution data here
            dataStore.PeakResolution[dataStore.currentPeak][dataStore.THESEdetectors.indexOf(thisPlotName)] = width*2.35;

            // Save ROI information again in case it was modified during the fitting
                dataStore.ROI[dataStore.currentPlot][dataStore.currentPeak][0] = dataStore.viewers[viewerName].FitLimitLower;
                dataStore.ROI[dataStore.currentPlot][dataStore.currentPeak][1] = dataStore.viewers[viewerName].FitLimitUpper;

            //update table
            this.updateTable(dataStore.currentPlot);

            //update plot
            dataStore.viewers[dataStore.plots[0]].plotData();

            //update resolution plot
            this.reconstructResolutionData();

            //update residuals plots
            if(dataStore.currentPeak==3){
              this.reconstructResidualsData(dataStore.currentPlot,dataStore.THESEdetectors.indexOf(thisPlotName));
              this.reconstructMidasResidualsData(dataStore.currentPlot,dataStore.THESEdetectors.indexOf(thisPlotName));
             }

            //disengage fit mode buttons
            if( parseInt(lowPeak.getAttribute('engaged'),10) == 1)
                lowPeak.onclick();
            if( parseInt(midPeak.getAttribute('engaged'),10) == 1)
                midPeak.onclick();
            if( parseInt(highPeak.getAttribute('engaged'),10) == 1)
                highPeak.onclick();
            if( parseInt(vhiPeak.getAttribute('engaged'),10) == 1)
                vhiPeak.onclick();

        },

        this.updateTable = function(spectrum){
            //update the report table with whatever is currently in the dataStore
            //recall dataStore.fitReults[plotTitle] = [[amplitude, center, width, slope, intercept],[...]], for [low energy, high energy].
            //<spectrumName>: string; name of spectrum, per names from analyzer
            //this: gainMatchReport object

            var calibration;
            var thisPlotName = spectrum;
            if(thisPlotName.includes(':')){
               thisPlotName = thisPlotName.split(':')[1].slice(0,10);
            }else{
               thisPlotName = thisPlotName.slice(0,10);
            }

            if(Array.isArray(dataStore.fitResults[spectrum][0]))
                document.getElementById(this.wrapID + thisPlotName + 'chan1').innerHTML = dataStore.fitResults[spectrum][0][1].toFixed(3);
            if(Array.isArray(dataStore.fitResults[spectrum][1]))
                document.getElementById(this.wrapID + thisPlotName + 'chan2').innerHTML = dataStore.fitResults[spectrum][1][1].toFixed(3);
            if(Array.isArray(dataStore.fitResults[spectrum][2]))
                document.getElementById(this.wrapID + thisPlotName + 'chan3').innerHTML = dataStore.fitResults[spectrum][2][1].toFixed(3);
            if(Array.isArray(dataStore.fitResults[spectrum][3]))
                document.getElementById(this.wrapID + thisPlotName + 'chan4').innerHTML = dataStore.fitResults[spectrum][3][1].toFixed(3);

                if(Array.isArray(dataStore.fitResults[spectrum][0]) && Array.isArray(dataStore.fitResults[spectrum][1]) && Array.isArray(dataStore.fitResults[spectrum][2])){

                  // Only need three peaks for RCMP
                  if(dataStore.detectorType == 'RCMP'){
                    // Linear fit for RCMP to only 3 peaks
                    calibration = this.calculateLinear(dataStore.fitResults[spectrum][0][1], dataStore.fitResults[spectrum][1][1], dataStore.fitResults[spectrum][2][1]);
                    calibration.push(0.0); // add the quadratic term
                    document.getElementById(this.wrapID + thisPlotName + 'offset').innerHTML = calibration[0].toFixed(8);
                    document.getElementById(this.wrapID + thisPlotName + 'gain').innerHTML = calibration[1].toFixed(8);
                    document.getElementById(this.wrapID + thisPlotName + 'quad').innerHTML = 0.0;
                    dataStore.fitResults[spectrum][4] = calibration
                  }

                  // Need the fourth peak as well for HPGe, LaBr3 and PACES
                  if(Array.isArray(dataStore.fitResults[spectrum][3])){
                    if(dataStore.detectorType == 'HPGe' || dataStore.detectorType == 'LaBr3'){
                      // Quadratic fit for HPGe
                      calibration = this.calculateQuadratic(dataStore.fitResults[spectrum][0][1], dataStore.fitResults[spectrum][1][1], dataStore.fitResults[spectrum][2][1], dataStore.fitResults[spectrum][3][1]);
                      document.getElementById(this.wrapID + thisPlotName + 'offset').innerHTML = calibration[0].toFixed(8);
                      document.getElementById(this.wrapID + thisPlotName + 'gain').innerHTML = calibration[1].toFixed(8);
                      document.getElementById(this.wrapID + thisPlotName + 'quad').innerHTML = calibration[2].toFixed(8);
                      dataStore.fitResults[spectrum][4] = calibration
                    }else if(dataStore.detectorType == 'PACES'){
                      // Linear fit for PACES
                      calibration = this.calculateLinear(dataStore.fitResults[spectrum][0][1], dataStore.fitResults[spectrum][1][1], dataStore.fitResults[spectrum][2][1], dataStore.fitResults[spectrum][3][1]);
                      calibration.push(0.0); // add the quadratic term
                      document.getElementById(this.wrapID + thisPlotName + 'offset').innerHTML = calibration[0].toFixed(8);
                      document.getElementById(this.wrapID + thisPlotName + 'gain').innerHTML = calibration[1].toFixed(8);
                      document.getElementById(this.wrapID + thisPlotName + 'quad').innerHTML = 0.0;
                      dataStore.fitResults[spectrum][4] = calibration
                    }
                  }
                }

            //highlight suspicious rows
            this.whatsNormal();
            this.highlightOutliers();

        },

                this.calculateLine = function(lowBin, highBin){
                    //given the positions of the low bin and high bin, return [intercept, slope] defining
                    //a striaght calibration line using the energies reported in the input.
                    //lowBin: number; center of low energy peak in bins
                    //highBin: number; center of high energy peak in bins
                    //this: gainMatchReport object

                    var lowEnergy = document.getElementById('peak1').value
                    var highEnergy = document.getElementById('peak2').value
                    var slope, intercept;

                    slope = (lowEnergy - highEnergy) / (lowBin - highBin);
                    intercept = lowEnergy - slope*lowBin

                    return [intercept, slope]

                },

                        this.calculateLinear = function(lowBin, midBin, highBin, vhiBin){
                            //given the positions of the low bin and high bin, return [intercept, slope] defining
                            //a striaght calibration line using the energies reported in the input.
                            //lowBin: number; center of low energy peak in bins
                            //highBin: number; center of high energy peak in bins
                            //vhiBin: number; center of top energy peak in bins
                            //this: gainMatchReport object

                                        var lowEnergy = document.getElementById('peak1').value
                                        var midEnergy = document.getElementById('peak2').value
                                        var highEnergy = document.getElementById('peak3').value
                                        var vhiEnergy = document.getElementById('peak4').value
                            var slope, intercept;

                            if(lowBin>0 && midBin>0 && highBin>0 && vhiBin>0){

                            data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
                            }else if(isNaN(lowBin) || lowBin<=0){
                            data = [[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
                            }else if(isNaN(midBin) || midBin<=0){
                            data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
                            }else if(isNaN(highBin) || highBin<=0){
                            data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
                            }else if(isNaN(vhiBin) || vhiBin<=0){
                            data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)]];
                            }else{ data = null;}

                            // Hats off to Tom Alexander, https://github.com/Tom-Alexander/regression-js
                            const result = regression.linear(data);

                            slope = result.equation[0];
                            intercept = result.equation[1];

                                        return [intercept, slope]

                        },

        this.calculateQuadratic = function(lowBin, midBin, highBin, vhiBin){
            //given the positions of the low bin and high bin, return [intercept, slope] defining
            //a striaght calibration line using the energies reported in the input.
            //lowBin: number; center of low energy peak in bins
            //highBin: number; center of high energy peak in bins
            //vhiBin: number; center of top energy peak in bins
            //this: gainMatchReport object

            var lowEnergy = document.getElementById('peak1').value
            var midEnergy = document.getElementById('peak2').value
            var highEnergy = document.getElementById('peak3').value
            var vhiEnergy = document.getElementById('peak4').value
            var quad, slope, intercept;
            var data = [];

if(lowBin>0 && midBin>0 && highBin>0 && vhiBin>0){

data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
}else if(isNaN(lowBin) || lowBin<=0){
data = [[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
}else if(isNaN(midBin) || midBin<=0){
data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
}else if(isNaN(highBin) || highBin<=0){
data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
}else if(isNaN(vhiBin) || vhiBin<=0){
data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)]];
}else{ data = null;}

// Hats off to Tom Alexander, https://github.com/Tom-Alexander/regression-js
const result = regression.polynomial(data, { order: 2, precision: 20 });

quad = result.equation[0];
slope = result.equation[1];
intercept = result.equation[2];

            return [intercept, slope, quad]

        },





        this.whatsNormal = function(){
            //identifies the mean and SD of the calibration quad, slope and intercept across all detectors

            var i, meanQuad = 0, sqMeanQuad = 0, meanSlope = 0, sqMeanSlope = 0, meanIntercept = 0, sqMeanIntercept = 0, sdQuad, sdSlope, sdIntercept,
                keys = Object.keys(dataStore.fitResults),
                numIntercept = 0, numSlope = 0, numQuad = 0

            for(i=0; i<keys.length; i++){
                if(dataStore.fitResults[keys[i]][4] && dataStore.fitResults[keys[i]][4][0]){
                    meanIntercept += dataStore.fitResults[keys[i]][2][0];
                    sqMeanIntercept += Math.pow(dataStore.fitResults[keys[i]][4][0], 2);
                    numIntercept++;
                }
                if(dataStore.fitResults[keys[i]][4] && dataStore.fitResults[keys[i]][4][1]){
                    meanSlope += dataStore.fitResults[keys[i]][2][1];
                    sqMeanSlope += Math.pow(dataStore.fitResults[keys[i]][4][1], 2);
                    numSlope++;
                }
                if(dataStore.fitResults[keys[i]][4] && dataStore.fitResults[keys[i]][4][2]){
                    meanQuad += dataStore.fitResults[keys[i]][2][2];
                    sqMeanQuad += Math.pow(dataStore.fitResults[keys[i]][4][2], 2);
                    numQuad++;
                }
            }

            meanIntercept /= numIntercept;
            sqMeanIntercept /= numIntercept;
            meanSlope /= numSlope;
            sqMeanSlope /= numSlope;
            meanQuad /= numQuad;
            sqMeanQuad /= numQuad;

            sdIntercept = Math.sqrt(sqMeanIntercept - Math.pow(meanIntercept,2));
            sdSlope = Math.sqrt(sqMeanSlope - Math.pow(meanSlope,2));
            sdQuad = Math.sqrt(sqMeanQuad - Math.pow(meanQuad,2));

            dataStore.meanCalib = [meanIntercept, meanSlope, meanQuad];
            dataStore.sdCalib = [sdIntercept, sdSlope, sdQuad];
        },

        this.highlightOutliers = function(){
          //step through the fit results, and highlight table rows corresponding to wacky channels
          //this: gainMatchReport object

          var i;
          var keys = Object.keys(dataStore.fitResults);
          var thisKey;

          var MaxOffset = 10;
          var MaxQuad = 0.00001;
          if(dataStore.detectorType == 'RCMP'){ MaxOffset = 300;   }

          for(i=0; i<keys.length; i++){
            if(!dataStore.fitResults[keys[i]][4]){ continue; }

            thisKey = keys[i];
            if(thisKey.includes(':')){
              thisKey = thisKey.split(':')[1].slice(0,10);
            }else{
              thisKey = thisKey.slice(0,10);
            }


            if( dataStore.fitResults[keys[i]][0] && dataStore.fitResults[keys[i]][1] && dataStore.fitResults[keys[i]][2] && (
            dataStore.fitResults[keys[i]][4][0] > dataStore.meanCalib[0] + dataStore.sdCalib[0]*3
            || dataStore.fitResults[keys[i]][4][0] < dataStore.meanCalib[0] - dataStore.sdCalib[0]*3
            || Math.abs(dataStore.fitResults[keys[i]][4][0]) > MaxOffset
            || dataStore.fitResults[keys[i]][4][1] > dataStore.meanCalib[1] + dataStore.sdCalib[1]*3
            || dataStore.fitResults[keys[i]][4][1] < dataStore.meanCalib[1] - dataStore.sdCalib[1]*3
            || dataStore.fitResults[keys[i]][4][2] > dataStore.meanCalib[2] + dataStore.sdCalib[2]*3
            || dataStore.fitResults[keys[i]][4][2] < dataStore.meanCalib[2] - dataStore.sdCalib[2]*3
            || Math.abs(dataStore.fitResults[keys[i]][4][2]) > MaxQuad
            )
            ){
              // Highlight raw as problem (red) if the parameters are not normal, and do not check the box
              document.getElementById(this.wrapID + thisKey + 'row').setAttribute('style', 'background-color: #FF0000;');
              document.getElementById(thisKey + 'write').checked = false;
            } else if(isNaN(dataStore.fitResults[keys[i]][0][1])
            || isNaN(dataStore.fitResults[keys[i]][1][1])
            || isNaN(dataStore.fitResults[keys[i]][2][1])  ){
              // Highlight row as warning (orange) if any of the peaks were not fitted when they should have been, and do not check the box

              if(dataStore.detectorType == 'RCMP'){
                document.getElementById(this.wrapID + thisKey + 'row').setAttribute('style', 'background-color: #F28C28;');
                document.getElementById(thisKey + 'write').checked = false;
              }else if(isNaN(dataStore.fitResults[keys[i]][3][1])){
                document.getElementById(this.wrapID + thisKey + 'row').setAttribute('style', 'background-color: #F28C28;');
                document.getElementById(thisKey + 'write').checked = false;
              }
            } else{
              // If all is good, check the box and do not highlight the row
              document.getElementById(this.wrapID + thisKey + 'row').setAttribute('style', '');
              document.getElementById(thisKey + 'write').checked = true;
            }
          }
        },

        this.reconstructResolutionData = function(){
            //arrange the latest resolution info for representation in the dygraph.

            var i, evt, detectorIndex = [],
            flags = [];
            flags.fillN(0, dataStore.THESEdetectors.length)

            for(i=0; i<dataStore.THESEdetectors.length; i++){
                detectorIndex[i] = i;
            }

            dataStore.resolutionData = arrangePoints(detectorIndex, [dataStore.PeakResolution[0], dataStore.PeakResolution[1], dataStore.PeakResolution[2], dataStore.PeakResolution[3]], flags );
            dispatcher({ 'data': dataStore.resolutionData }, 'updateDyData0');
        },

        this.reconstructResidualsData = function(currentSpectrum,currentDetNum){
            // First determine the residuals by applying the calibration coefficients to the fitted centroid, then comparing it to the literature energy.
            // Save the residuals data to the dataStore, then
            //arrange the latest residual info for representation in the dygraph.

             var thisOffset = dataStore.fitResults[currentSpectrum][4][0];
             var thisGain = dataStore.fitResults[currentSpectrum][4][1];
             var thisQuadratic = dataStore.fitResults[currentSpectrum][4][2];

             for(currentPeak=0; currentPeak<dataStore.sourceInfo[dataStore.detectorType][dataStore.sourceInfo[dataStore.detectorType].map(function(e) { return e.name; }).indexOf(dataStore.sourceType)].energies.length; currentPeak++){
               var peakIndex = currentPeak+1;
               var literatureEnergy = document.getElementById('peak'+peakIndex).value;


               // Save the data for the residuals plots
               thisCentroid = dataStore.fitResults[currentSpectrum][currentPeak][1];
               dataStore.residualsData[peakIndex][currentDetNum] = literatureEnergy - ( thisOffset  + (thisGain*thisCentroid) + (thisQuadratic*thisCentroid*thisCentroid) );

               var i, evt, detectorIndex = [],
               flags = [];
               flags.fillN(0, dataStore.THESEdetectors.length)

               for(i=0; i<dataStore.THESEdetectors.length; i++){
                  detectorIndex[i] = i;
               }

               // Update the Y axis scale if needed
               if(dataStore.residualsData[peakIndex][currentDetNum] < (0.75 * dataStore.YAxisMinValue[peakIndex][0])){
                 var newYAxisMinValue = dataStore.residualsData[peakIndex][currentDetNum] * 1.33;
                 dataStore.YAxisMinValue[1][0] = dataStore.YAxisMinValue[2][0] = dataStore.YAxisMinValue[3][0] = dataStore.YAxisMinValue[4][0] = newYAxisMinValue;
               }
               if(dataStore.residualsData[peakIndex][currentDetNum] > (0.75 * dataStore.YAxisMaxValue[peakIndex][0])){
                 var newYAxisMaxValue = dataStore.residualsData[peakIndex][currentDetNum] * 1.33;
                 dataStore.YAxisMaxValue[1][0] = dataStore.YAxisMaxValue[2][0] = dataStore.YAxisMaxValue[3][0] = dataStore.YAxisMaxValue[4][0] = newYAxisMaxValue;
               }

               dataStore.dataplotData[peakIndex] = arrangePoints(detectorIndex, [dataStore.residualsData[peakIndex]], flags );
               var eventString = 'updateDyData'+peakIndex;

               dispatcher({ 'data': dataStore.dataplotData[peakIndex] }, eventString);
            }

            // Update the mean and standard deviation of the dataset
            this.calculateResidualsSD();
        },

        this.reconstructMidasResidualsData = function(currentSpectrum,currentDetNum){
            // First determine the residuals by applying the calibration coefficients from the server to the fitted centroid, then comparing it to the literature energy.
            // Save the residuals data to the dataStore, then
            //arrange the latest residual info for representation in the dygraph.

            var thisPlotName = currentSpectrum;
            if(thisPlotName.includes(':')){
               thisPlotName = thisPlotName.split(':')[1];
            }

             var thisOffset = dataStore.midasCalibration[thisPlotName][0];
             var thisGain = dataStore.midasCalibration[thisPlotName][1];
             var thisQuadratic = dataStore.midasCalibration[thisPlotName][2];

             for(currentPeak=0; currentPeak<dataStore.sourceInfo[dataStore.detectorType][dataStore.sourceInfo[dataStore.detectorType].map(function(e) { return e.name; }).indexOf(dataStore.sourceType)].energies.length; currentPeak++){
               var peakIndex = currentPeak+1;
               var literatureEnergy = document.getElementById('peak'+peakIndex).value;
               peakIndex +=4;

               // Save the data for the residuals plots
               thisCentroid = dataStore.fitResults[currentSpectrum][currentPeak][1];
               dataStore.residualsData[peakIndex][currentDetNum] = literatureEnergy - ( thisOffset  + (thisGain*thisCentroid) + (thisQuadratic*thisCentroid*thisCentroid) );

               var i, evt, detectorIndex = [],
               flags = [];
               flags.fillN(0, dataStore.THESEdetectors.length)

               for(i=0; i<dataStore.THESEdetectors.length; i++){
                  detectorIndex[i] = i;
               }

               // Update the Y axis scale if needed
               if(dataStore.residualsData[peakIndex][currentDetNum] < (0.75 * dataStore.YAxisMinValue[peakIndex][0])){
                 var newYAxisMinValue = dataStore.residualsData[peakIndex][currentDetNum] * 1.33;
                 dataStore.YAxisMinValue[5][0] = dataStore.YAxisMinValue[6][0] = dataStore.YAxisMinValue[7][0] = dataStore.YAxisMinValue[8][0] = newYAxisMinValue;
               }
               if(dataStore.residualsData[peakIndex][currentDetNum] > (0.75 * dataStore.YAxisMaxValue[peakIndex][0])){
                 var newYAxisMaxValue = dataStore.residualsData[peakIndex][currentDetNum] * 1.33;
                 dataStore.YAxisMaxValue[5][0] = dataStore.YAxisMaxValue[6][0] = dataStore.YAxisMaxValue[7][0] = dataStore.YAxisMaxValue[8][0] = newYAxisMaxValue;
               }

               dataStore.dataplotData[peakIndex] = arrangePoints(detectorIndex, [dataStore.residualsData[peakIndex]], flags );
               var eventString = 'updateDyData'+peakIndex;
               dispatcher({ 'data': dataStore.dataplotData[peakIndex] }, eventString);
            }

            // Update the mean and standard deviation of the dataset
            this.calculateMidasResidualsSD();
        },

        this.calculateResidualsSD = function(){
            //identifies the mean and SD of the residuals across all detectors

            var i, meanP1 = 0, sqMeanP1 = 0, meanP2 = 0, sqMeanP2 = 0, meanP3 = 0, sqMeanP3 = 0, meanP4 = 0, sqMeanP4 = 0,
                numP1 = 0, numP2 = 0, numP3 = 0, numP4 = 0;

            for(i=0; i<dataStore.residualsData.length; i++){
                if(dataStore.residualsData[1][i]){
                    meanP1 += dataStore.residualsData[1][i];
                    sqMeanP1 += Math.pow(dataStore.residualsData[1][i],2);
                    numP1++;
                }
                if(dataStore.residualsData[2][i]){
                    meanP2 += dataStore.residualsData[2][i];
                    sqMeanP2 += Math.pow(dataStore.residualsData[2][i],2);
                    numP2++;
                }
                if(dataStore.residualsData[3][i]){
                    meanP3 += dataStore.residualsData[3][i];
                    sqMeanP3 += Math.pow(dataStore.residualsData[3][i],2);
                    numP3++;
                }
                if(dataStore.residualsData[4][i]){
                    meanP4 += dataStore.residualsData[4][i];
                    sqMeanP4 += Math.pow(dataStore.residualsData[4][i],2);
                    numP4++;
                }
            }

            meanP1 /= numP1;
            meanP2 /= numP2;
            meanP3 /= numP3;
            meanP4 /= numP4;

            sqMeanP1 /= numP1;
            sqMeanP2 /= numP2;
            sqMeanP3 /= numP3;
            sqMeanP4 /= numP4;


            sdMeanP1 = Math.sqrt(sqMeanP1 - Math.pow(meanP1,2));
            sdMeanP2 = Math.sqrt(sqMeanP2 - Math.pow(meanP2,2));
            sdMeanP3 = Math.sqrt(sqMeanP3 - Math.pow(meanP3,2));
            sdMeanP4 = Math.sqrt(sqMeanP4 - Math.pow(meanP4,2));

            dataStore.residualsDataMean = [0, meanP1, meanP2, meanP3, meanP4];
            dataStore.residualsDataSD = [0, sqMeanP1, sqMeanP2, sqMeanP3, sqMeanP4];

            document.getElementById('residualP1newText').innerHTML  = 'Peak1 residuals: Mean: '+meanP1.toFixed(3)+', Standard Deviation: '+sdMeanP1.toFixed(3)+' keV';
            document.getElementById('residualP2newText').innerHTML  = 'Peak2 residuals: Mean: '+meanP2.toFixed(3)+', Standard Deviation: '+sdMeanP2.toFixed(3)+' keV';
            document.getElementById('residualP3newText').innerHTML  = 'Peak3 residuals: Mean: '+meanP3.toFixed(3)+', Standard Deviation: '+sdMeanP3.toFixed(3)+' keV';
            document.getElementById('residualP4newText').innerHTML  = 'Peak4 residuals: Mean: '+meanP4.toFixed(3)+', Standard Deviation: '+sdMeanP4.toFixed(3)+' keV';
        },

        this.calculateMidasResidualsSD = function(){
            //identifies the mean and SD of the residuals across all detectors

            var i, meanP1 = 0, sqMeanP1 = 0, meanP2 = 0, sqMeanP2 = 0, meanP3 = 0, sqMeanP3 = 0, meanP4 = 0, sqMeanP4 = 0,
                numP1 = 0, numP2 = 0, numP3 = 0, numP4 = 0;

            for(i=0; i<dataStore.residualsData.length; i++){
                if(dataStore.residualsData[5][i]){
                    meanP1 += dataStore.residualsData[5][i];
                    sqMeanP1 += Math.pow(dataStore.residualsData[5][i],2);
                    numP1++;
                }
                if(dataStore.residualsData[6][i]){
                    meanP2 += dataStore.residualsData[6][i];
                    sqMeanP2 += Math.pow(dataStore.residualsData[6][i],2);
                    numP2++;
                }
                if(dataStore.residualsData[7][i]){
                    meanP3 += dataStore.residualsData[7][i];
                    sqMeanP3 += Math.pow(dataStore.residualsData[7][i],2);
                    numP3++;
                }
                if(dataStore.residualsData[8][i]){
                    meanP4 += dataStore.residualsData[8][i];
                    sqMeanP4 += Math.pow(dataStore.residualsData[8][i],2);
                    numP4++;
                }
            }

            meanP1 /= numP1;
            meanP2 /= numP2;
            meanP3 /= numP3;
            meanP4 /= numP4;

            sqMeanP1 /= numP1;
            sqMeanP2 /= numP2;
            sqMeanP3 /= numP3;
            sqMeanP4 /= numP4;


            sdMeanP1 = Math.sqrt(sqMeanP1 - Math.pow(meanP1,2));
            sdMeanP2 = Math.sqrt(sqMeanP2 - Math.pow(meanP2,2));
            sdMeanP3 = Math.sqrt(sqMeanP3 - Math.pow(meanP3,2));
            sdMeanP4 = Math.sqrt(sqMeanP4 - Math.pow(meanP4,2));

            dataStore.residualsDataMean = [0, meanP1, meanP2, meanP3, meanP4];
            dataStore.residualsDataSD = [0, sqMeanP1, sqMeanP2, sqMeanP3, sqMeanP4];

            document.getElementById('residualP1midText').innerHTML  = 'Peak1 residuals: Mean: '+meanP1.toFixed(3)+', Standard Deviation: '+sdMeanP1.toFixed(3)+' keV';
            document.getElementById('residualP2midText').innerHTML  = 'Peak2 residuals: Mean: '+meanP2.toFixed(3)+', Standard Deviation: '+sdMeanP2.toFixed(3)+' keV';
            document.getElementById('residualP3midText').innerHTML  = 'Peak3 residuals: Mean: '+meanP3.toFixed(3)+', Standard Deviation: '+sdMeanP3.toFixed(3)+' keV';
            document.getElementById('residualP4midText').innerHTML  = 'Peak4 residuals: Mean: '+meanP4.toFixed(3)+', Standard Deviation: '+sdMeanP4.toFixed(3)+' keV';
        },

        this.updateEnergies = function(){
            //callback for the calibration source dropdown; updates energy input boxes with standard values
            //this: gainMatchReport object

            var calibrationSourceName = getSelected(this.wrapID + 'calibrationSource');

            // Find the index number for the source information for this sourceType
            var index = dataStore.sourceInfo[dataStore.detectorType].map(function(e) { return e.name; }).indexOf(calibrationSourceName);

            // Set the peak energies for this source
            document.getElementById('peak1').value  = dataStore.sourceInfo[dataStore.detectorType][index].lowEnergy;
            document.getElementById('peak2').value  = dataStore.sourceInfo[dataStore.detectorType][index].midEnergy;
            document.getElementById('peak3').value = dataStore.sourceInfo[dataStore.detectorType][index].highEnergy;
            document.getElementById('peak4').value  = dataStore.sourceInfo[dataStore.detectorType][index].vhiEnergy;

        },

        this.customEnergy = function(){
            //callback for changing the calibration energies to custom values
            //this: gainMatchReport object

            var i, keys = Object.keys(dataStore.fitResults)
            var defaultSources = document.getElementById(this.wrapID + 'calibrationSource')

            defaultSources.value = 'custom'
        },

        this.toggleFitMode = function(){
            //gain matcher needs special fit controls for convenience
            //this: fit mode engage button element

            var viewerName = dataStore.plots[0];

            if(parseInt(this.getAttribute('engaged'),10) == 0){
                dataStore.viewers[viewerName].setupFitMode();
                this.setAttribute('engaged', 1);
                if(this.id == 'fitLow')
                    document.getElementById('refitLoBadge').classList.add('red-text')
                if(this.id == 'fitMid')
                    document.getElementById('refitMidBadge').classList.add('red-text')
                if(this.id == 'fitHigh')
                    document.getElementById('refitHiBadge').classList.add('red-text')
                if(this.id == 'fitvHi')
                    document.getElementById('refitvHiBadge').classList.add('red-text')
            }
            else{
                dataStore.viewers[viewerName].leaveFitMode();
                this.setAttribute('engaged', 0);
                if(this.id == 'fitLow')
                    document.getElementById('refitLoBadge').classList.remove('red-text')
                if(this.id == 'fitMid')
                    document.getElementById('refitMidBadge').classList.remove('red-text')
                if(this.id == 'fitHigh')
                    document.getElementById('refitHiBadge').classList.remove('red-text')
                if(this.id == 'fitvHi')
                    document.getElementById('refitvHiBadge').classList.remove('red-text')
            }

            if(this.id == 'fitLow')
                dataStore.currentPeak = 0
            else if(this.id == 'fitMid')
                dataStore.currentPeak = 1
             else if(this.id == 'fitHigh')
                dataStore.currentPeak = 2
            else
                dataStore.currentPeak = 3

        },

        this.toggleAnalyzerwrite = function(){
            //toggle Analyzer writing permission.

            var allowed = document.getElementById(this.wrapID + 'yesDefinitelyWriteAnalyzer').checked

            if(allowed)
                document.getElementById(this.wrapID + 'writeToAnalyzer').removeAttribute('disabled');
            else
                document.getElementById(this.wrapID + 'writeToAnalyzer').setAttribute('disabled', true);
        }

        this.toggleODBwrite = function(){
            //toggle odb writing permission.

            var allowed = document.getElementById(this.wrapID + 'yesDefinitelyWriteODB').checked

            if(allowed)
                document.getElementById(this.wrapID + 'writeToODB').removeAttribute('disabled');
            else
                document.getElementById(this.wrapID + 'writeToODB').setAttribute('disabled', true);
        }

        this.toggleAllODBWrites = function(){
            // make each channel's odb write toggle match the master switch

            var toggles = document.getElementsByClassName('write-to-odb'),
                master = document.getElementById('writeAllChannels'),
                state = master.checked,
                i;

            for(i=0; i<toggles.length; i++){
                toggles[i].checked = state;
            }

        }

    }
</script>
