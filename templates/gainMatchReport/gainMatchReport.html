<link rel="stylesheet" href="gainMatchReport.css"/>

<template id='gainMatchReport'>
    <div class='sectionWrapper item'>
        <div class='col-md-12'>
            <table id='{{id}}gainMatchingResults' class='table gainTable'></table>

            <button type="button" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myAnalyzerModal">
                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write calibration to Analyzer
            </button>
<br>
            <button type="button" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myODBModal">
                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write calibration to ODB
            </button>
<br>
            <button type="button" class="btn btn-primary btn-lg"  id='saveCal'>
                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Save Cal file
            </button>
	    <input id='saveCalname' type='text' value='GRIFFIN-Cal-File.cal' size='48'></input>

        </div>
    </div>

    <!--are you sure modal for Analyzer write-->
    <div class="modal fade" id="myAnalyzerModal" tabindex="-1" role="dialog" aria-labelledby="myAnalyzerModalLabel">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                    <h4 class="modal-title" id="myAnalyzerModalLabel">Change values in Analyzer Config file?</h4>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to change the quadratic, gain and offset values for all selected detectors in the Analyzer? There is no undo.</p>
                    <input type='checkbox' id='{{id}}yesDefinitelyWriteAnalyzer'></input>
                    <label for='{{id}}yesDefinitelyWriteAnalyzer'>I'm very sure.</label>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal" id='dismissAnalyzermodal'>
                        <span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span> Abort
                    </button>
                    <button type="button" class="btn btn-default" id='{{id}}writeToAnalyzer' disabled>
                        <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!--are you sure modal for ODB write-->
    <div class="modal fade" id="myODBModal" tabindex="-1" role="dialog" aria-labelledby="myODBModalLabel">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                    <h4 class="modal-title" id="myODBModalLabel">Change values in ODB?</h4>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to change the quadratic, gain and offset values for all selected detectors in the ODB? There is no undo.</p>
                    <input type='checkbox' id='{{id}}yesDefinitelyWriteODB'></input>
                    <label for='{{id}}yesDefinitelyWriteODB'>I'm very sure.</label>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal" id='dismissODBmodal'>
                        <span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span> Abort
                    </button>
                    <button type="button" class="btn btn-default" id='{{id}}writeToODB' disabled>
                        <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write
                    </button>
                </div>
            </div>
        </div>
    </div>
</template>

<script>
    function gainMatchReport(wrapID, setupWrapID){

        this.wrapID = wrapID;
        this.setupWrapID = setupWrapID;
        this.wrap = document.getElementById(wrapID);
        this.setupWrap = document.getElementById(setupWrapID)

    this.setup = function(){

            // build list of source titles
    var listOfSourceTitles = [];

    if(dataStore.THESEdetectors[0].includes('PAC')){
      for(var i=0; i<dataStore.sourceInfoPACES.length; i++){
        var thisObject = {
          "name" : dataStore.sourceInfoPACES[i].name,
          "title" : dataStore.sourceInfoPACES[i].title
        }
        listOfSourceTitles.push(thisObject);
      }
    }else{
      for(var i=0; i<dataStore.sourceInfo.length; i++){
        var thisObject = {
          "name" : dataStore.sourceInfo[i].name,
          "title" : dataStore.sourceInfo[i].title
        }
        listOfSourceTitles.push(thisObject);
      }
    }

            //inject templates
            this.setupWrap.innerHTML = Mustache.to_html(
                dataStore.templates.gainMatchSetupBar,
                {
                    'id': this.setupWrapID,
                    'sourceTitle': listOfSourceTitles
                }
            );

            this.wrap.innerHTML = Mustache.to_html(
                dataStore.templates.gainMatchReport,
                {
                    'id': this.wrapID,
                }
            );
            // table has to be done as a separate template, since templates and tables don't play too nice together
            document.getElementById(this.wrapID + 'gainMatchingResults').innerHTML= Mustache.to_html(
                dataStore.templates.matchReportTable,
                {
                    'id': this.wrapID,
                    'detectors': dataStore.THESEdetectors
                }
            );

            //plug in fit all button
            document.getElementById('fitAll').onclick = this.fitAll.bind(this);
            document.getElementById('fitAll').removeAttribute('disabled');

            //plug in calibration source dropdown
            document.getElementById('gainMatchercalibrationSource').onchange = this.updateEnergies.bind(this);

            //plug in peak energy inputs
            document.getElementById('peak1').onchange = this.customEnergy.bind(this);
            document.getElementById('peak2').onchange = this.customEnergy.bind(this);
            document.getElementById('peak3').onchange = this.customEnergy.bind(this);
            document.getElementById('peak4').onchange = this.customEnergy.bind(this);

            // plug in onclick functions to the spectrum name cells
            for(var i=0; i<dataStore.THESEdetectors.length; i++){
              thisSpectrum = dataStore.THESEdetectors[i] + '_Pulse_Height';
              document.getElementById(this.wrapID + dataStore.THESEdetectors[i] + 'name').onclick = function(){
              var plot = this.innerHTML + '_Pulse_Height';
              if(dataStore.histoFileName.length>0){
                plot = dataStore.histoFileName + ':' + plot;
              }
              dataStore._plotListLite.exclusivePlot(this.innerHTML, dataStore.viewers[dataStore.plots[0]]);
              document.body.scrollTop = document.documentElement.scrollTop = 0;
             }
            }

            //plug in write to odb toggles
            document.getElementById('writeAllChannels').onchange = this.toggleAllODBWrites.bind(this);

            //make sure the file name for Cal file download gets passed around:
             document.getElementById('saveCalname').onchange = function(){
            //set the filename to whatever the user has requested:
             document.getElementById('saveCal').download = this.value;
            }

            // Set up the Cal file button
            document.getElementById('saveCal').onclick = function(){ buildCalfile(); }

            //set up fit callbacks
            dataStore.viewers[dataStore.plots[0]].fitCallback = this.fitCallback.bind(this);

            //plug in the allow Analyzer write switch
            document.getElementById(this.wrapID + 'yesDefinitelyWriteAnalyzer').onchange = this.toggleAnalyzerwrite.bind(this);

            //plug in write to Analyzer button
            document.getElementById(this.wrapID + 'writeToAnalyzer').onclick = function(){
                //bail out if there's no fit yet
                if(Object.keys(dataStore.fitResults).length == 0){
                    window.alert('You need to perform the gain match (see button at top of page) before writing results to the Analyzer.');
                    document.getElementById('dismissAnalyzermodal').click();
                }
                updateAnalyzer();
            }

            //plug in the allow ODB write switch
            document.getElementById(this.wrapID + 'yesDefinitelyWriteODB').onchange = this.toggleODBwrite.bind(this);

            //plug in write to odb button
            document.getElementById(this.wrapID + 'writeToODB').onclick = function(){
                //bail out if there's no fit yet
                if(Object.keys(dataStore.fitResults).length == 0){
                    window.alert('You need to perform the gain match (see button at top of page) before writing results to the ODB.');
                    document.getElementById('dismissODBmodal').click();
                }
                promiseScript(dataStore.ODBrequests[0]);
            }
        },

        this.fitAll = function(){
            //fit all spectra to the peaks defined.
//this: gainMatchReport object

            var i, keys = Object.keys(dataStore.rawData),
                buffer = dataStore.currentPlot //keep track of whatever was originally plotted so we can return to it

            releaser(
                function(i){
                    var keys = Object.keys(dataStore.rawData);
                    this.fitSpectra(keys[i])
                    document.getElementById('progress').setAttribute('style', 'width:' + (100*(keys.length - i) / keys.length) + '%' )
                }.bind(this),

                function(){
                    var evt;
                    //set up fit line re-drawing
                    dataStore.viewers[dataStore.plots[0]].drawCallback = this.addFitLines;

                    //comunicate with the user
                    if(document.getElementById('pickerMessage')){ deleteNode('pickerMessage') }
                    document.getElementById('reviewMessage').classList.remove('hidden');

                    //leave the viewer pointing at the first spectrum for fitting
                    dispatcher({target: buffer}, 'fitAllComplete')

                    //highlight suspicious rows
                    this.whatsNormal();
                    this.highlightOutliers();

                }.bind(this),

                keys.length-1
            )
        },

        this.fitSpectra = function(spectrum){
            //redo the fits for the named spectrum.
            //<spectrum>: string; name of spectrum, per names from analyzer
            //this: gainMatchReport object

            var viewerName = dataStore.plots[0];

            //identify regions of interest
            this.guessPeaks(spectrum, dataStore.rawData[spectrum]);

            //set up fitting
            dataStore.viewers[viewerName].addData(spectrum, JSON.parse(JSON.stringify(dataStore.rawData[spectrum])) );
            dataStore.currentPlot = spectrum;
            dataStore.viewers[viewerName].plotData() //kludge to update limits, could be nicer
            dataStore.viewers[viewerName].fitTarget = spectrum;

            //first peak
            dataStore.currentPeak = 0
            dataStore.viewers[viewerName].FitLimitLower = dataStore.ROI[spectrum].ROIlower[0]
            dataStore.viewers[viewerName].FitLimitUpper = dataStore.ROI[spectrum].ROIlower[1]
            dataStore.viewers[viewerName].fitData(spectrum, 0);

            //second peak
            dataStore.currentPeak = 1
            dataStore.viewers[viewerName].FitLimitLower = dataStore.ROI[spectrum].ROImiddle[0]
            dataStore.viewers[viewerName].FitLimitUpper = dataStore.ROI[spectrum].ROImiddle[1]
            dataStore.viewers[viewerName].fitData(spectrum, 0);

            //third peak
            dataStore.currentPeak = 2
            dataStore.viewers[viewerName].FitLimitLower = dataStore.ROI[spectrum].ROIupper[0]
            dataStore.viewers[viewerName].FitLimitUpper = dataStore.ROI[spectrum].ROIupper[1]
            dataStore.viewers[viewerName].fitData(spectrum, 0);

            //fourth peak
            dataStore.currentPeak = 3
            dataStore.viewers[viewerName].FitLimitLower = dataStore.ROI[spectrum].ROItop[0]
            dataStore.viewers[viewerName].FitLimitUpper = dataStore.ROI[spectrum].ROItop[1]
            dataStore.viewers[viewerName].fitData(spectrum, 0);

            //dump data so it doesn't stack up
            dataStore.viewers[viewerName].removeData(spectrum);
        },

        this.addFitLines = function(){
            //add current fits to the plot

            var lower, upper, middle
                viewerName = dataStore.plots[0];

            dataStore.viewers[viewerName].containerFit.removeAllChildren();

            //add fit lines
            lower = dataStore.viewers[viewerName].addFitLine(
                        dataStore.ROI[dataStore.currentPlot].ROIlower[0],
                        dataStore.ROI[dataStore.currentPlot].ROIlower[1] - dataStore.ROI[dataStore.currentPlot].ROIlower[0],
                        dataStore.fitResults[dataStore.currentPlot][0][0],
                        dataStore.fitResults[dataStore.currentPlot][0][1],
                        dataStore.fitResults[dataStore.currentPlot][0][2],
                        dataStore.fitResults[dataStore.currentPlot][0][3],
                        dataStore.fitResults[dataStore.currentPlot][0][4]
                    );

            middle = dataStore.viewers[viewerName].addFitLine(
                        dataStore.ROI[dataStore.currentPlot].ROImiddle[0],
                        dataStore.ROI[dataStore.currentPlot].ROImiddle[1] - dataStore.ROI[dataStore.currentPlot].ROImiddle[0],
                        dataStore.fitResults[dataStore.currentPlot][1][0],
                        dataStore.fitResults[dataStore.currentPlot][1][1],
                        dataStore.fitResults[dataStore.currentPlot][1][2],
                        dataStore.fitResults[dataStore.currentPlot][1][3],
                        dataStore.fitResults[dataStore.currentPlot][1][4]
                    );

            upper = dataStore.viewers[viewerName].addFitLine(
                        dataStore.ROI[dataStore.currentPlot].ROIupper[0],
                        dataStore.ROI[dataStore.currentPlot].ROIupper[1] - dataStore.ROI[dataStore.currentPlot].ROIupper[0],
                        dataStore.fitResults[dataStore.currentPlot][2][0],
                        dataStore.fitResults[dataStore.currentPlot][2][1],
                        dataStore.fitResults[dataStore.currentPlot][2][2],
                        dataStore.fitResults[dataStore.currentPlot][2][3],
                        dataStore.fitResults[dataStore.currentPlot][2][4]
                    );

            vupper = dataStore.viewers[viewerName].addFitLine(
                        dataStore.ROI[dataStore.currentPlot].ROItop[0],
                        dataStore.ROI[dataStore.currentPlot].ROItop[1] - dataStore.ROI[dataStore.currentPlot].ROItop[0],
                        dataStore.fitResults[dataStore.currentPlot][3][0],
                        dataStore.fitResults[dataStore.currentPlot][3][1],
                        dataStore.fitResults[dataStore.currentPlot][3][2],
                        dataStore.fitResults[dataStore.currentPlot][3][3],
                        dataStore.fitResults[dataStore.currentPlot][3][4]
                    );
            dataStore.viewers[viewerName].containerFit.addChild(lower)
            dataStore.viewers[viewerName].containerFit.addChild(middle)
            dataStore.viewers[viewerName].containerFit.addChild(upper)
            dataStore.viewers[viewerName].containerFit.addChild(vupper)

            dataStore.viewers[viewerName].stage.update();
        },

        this.guessPeaks = function(spectrumName, data){
            //given a spectrum <data>, identify the bins corresponding to the maxima of the two largest peaks.
            //register a range around those peaks as our automated guesses for where the gammas of interest lie.
            //<spectrumName>: string; name of spectrum, per names from analyzer
            //<data>: array; bin contents for a spectrum, array index == bin number.
            //this: gainMatchReport object

            var lowPeakIndex = parseInt(document.getElementById('peak1position').value,10),
                medPeakIndex = parseInt(document.getElementById('peak2position').value,10),
                highPeakIndex = parseInt(document.getElementById('peak3position').value,10),
                vhiPeakIndex = parseInt(document.getElementById('peak4position').value,10),
                centers = [],
                ROIwidth = 4,
                i,j;
var sum=0;
var average=1;
var foundP1peaks = [], foundP1id=0;
var foundP2peaks = [], foundP2id=0;
var foundP3peaks = [], foundP3id=0;
var foundP4peaks = [], foundP4id=0;
var thisSearchRegion = [];

// Different detector types have different energy resolution
      if(dataStore.detectorType == 'LaBr3'){
        ROIwidth = 20;
      }

// Now we have three search regions instead of a single search region

 // identify the peak center of the three highest peaks within the search region for Peak 1
 searchLength = Math.floor((dataStore.searchRegionP1[1] - dataStore.searchRegionP1[0]));
 centers[0]=1;   foundP1id=0;
 thisSearchRegion[0] = dataStore.searchRegionP1[0];
 thisSearchRegion[1] = dataStore.searchRegionP1[1];
 while(foundP1id<3){
      thisPeak=thisSearchRegion[0];
      for(i=thisSearchRegion[0]; i<(thisSearchRegion[1]); i++){
         if(foundP1id>0 && i > (foundP1peaks[0]-5) && i < (foundP1peaks[0]+5)){ continue; }
         if(foundP1id>1 && i > (foundP1peaks[1]-5) && i < (foundP1peaks[1]+5)){ continue; }
         localPBG = (data[i-4]+data[i-3]+data[i-2]+data[i-1]+data[i]+data[i+1]+data[i+2]+data[i+3]) / (data[i-8]+data[i-7]+data[i-6]+data[i-5]+data[i+5]+data[i+6]+data[i+7]+data[i+8]);
         if(data[i] > data[thisPeak] && localPBG>0.5){
           thisPeak=i;
         }
      }

 if(thisPeak>thisSearchRegion[0]){
   foundP1peaks[foundP1id]=thisPeak;
   foundP1id++;
 }else if(foundP1id<1){
         thisSearchRegion[0] += 10;
         if(thisSearchRegion[0]>(thisSearchRegion[1] - 20)){
           foundP1id=3;
          }
         }else{
               foundP1peaks[2]=foundP1peaks[1]=foundP1peaks[0];  foundP1id=3;

         }
    }
 centers[0]=foundP1peaks[0];

 // identify the peak center of the three highest peaks within the search region for Peak 2
 searchLength = Math.floor((dataStore.searchRegionP2[1] - dataStore.searchRegionP2[0]));
 centers[1]=1;   foundP2id=0;
 thisSearchRegion[0] = dataStore.searchRegionP2[0];
 thisSearchRegion[1] = dataStore.searchRegionP2[1];
 if(thisSearchRegion[0]<(centers[0]+5)){ thisSearchRegion[0] = (centers[0]+10); }
 while(foundP2id<3){
      thisPeak=thisSearchRegion[0];
      for(i=thisSearchRegion[0]; i<(thisSearchRegion[1]); i++){
         if((i > (centers[0]-5) && i < (centers[0]+5))){ continue; }
         if(foundP2id>0 && i > (foundP2peaks[0]-5) && i < (foundP2peaks[0]+5)){ continue; }
         if(foundP2id>1 && i > (foundP2peaks[1]-5) && i < (foundP2peaks[1]+5)){ continue; }
         localPBG = (data[i-4]+data[i-3]+data[i-2]+data[i-1]+data[i]+data[i+1]+data[i+2]+data[i+3]) / (data[i-8]+data[i-7]+data[i-6]+data[i-5]+data[i+5]+data[i+6]+data[i+7]+data[i+8]);
         if(data[i] > data[thisPeak] && localPBG>0.5){
           thisPeak=i;
         }
      }

 if(thisPeak>thisSearchRegion[0]){
   foundP2peaks[foundP2id]=thisPeak;
   foundP2id++;
 }else if(foundP2id<1){
         thisSearchRegion[0] += 10;
         if(thisSearchRegion[0]>(thisSearchRegion[1] - 20)){
           foundP2id=3;
          }
         }else{
               foundP2peaks[2]=foundP2peaks[1]=foundP2peaks[0];  foundP2id=3;

         }
 }
 centers[1]=foundP2peaks[0];

 // identify the peak center of the three highest peaks within the search region for Peak 3
 searchLength = Math.floor((dataStore.searchRegionP3[1] - dataStore.searchRegionP3[0]));
 centers[2]=1;   foundP3id=0;
 thisSearchRegion[0] = dataStore.searchRegionP3[0];
 thisSearchRegion[1] = dataStore.searchRegionP3[1];
 if(thisSearchRegion[0]<(centers[1]+5)){ thisSearchRegion[0] = (centers[1]+10); }
 while(foundP3id<3){
      thisPeak=thisSearchRegion[0];


        localPBGSetting = 0.5;
    if(dataStore.modeType == 'Histo' && dataStore.detectorType == 'HPGe'){
      if(document.getElementById("automaticCalibration-Sr-90").value == "Sr-90"){
      // 90Sr has significant background from Bremsstrahliung so search this region backwards.
        localPBGSetting = 1.25;
      }
}
       for(i=thisSearchRegion[0]; i<(thisSearchRegion[1]); i++){
           if((i > (centers[0]-5) && i < (centers[0]+5)) || (i >  (centers[1]-5) && i < (centers[1]+5))){ continue; }
           if(foundP3id>0 && i > (foundP3peaks[0]-5) && i < (foundP3peaks[0]+5)){ continue; }
           if(foundP3id>1 && i > (foundP3peaks[1]-5) && i < (foundP3peaks[1]+5)){ continue; }
           localPBG = (data[i-4]+data[i-3]+data[i-2]+data[i-1]+data[i]+data[i+1]+data[i+2]+data[i+3]) / (data[i-8]+data[i-7]+data[i-6]+data[i-5]+data[i+5]+data[i+6]+data[i+7]+data[i+8]);
           if(data[i] > data[thisPeak] && localPBG>localPBGSetting){ thisPeak=i; }
        }

 if(thisPeak>thisSearchRegion[0]){
   foundP3peaks[foundP3id]=thisPeak;
   foundP3id++;
 }else if(foundP3id<1){
         thisSearchRegion[0] += 10;
         if(thisSearchRegion[0]>(thisSearchRegion[1] - 20)){
           foundP3id=3;
          }
         }else{
               foundP3peaks[2]=foundP3peaks[1]=foundP3peaks[0];  foundP3id=3;

         }
    }
 centers[2]=foundP3peaks[0];

 // identify the peak center of the three highest peaks within the search region for Peak 4
 searchLength = Math.floor((dataStore.searchRegionP4[1] - dataStore.searchRegionP4[0]));
 centers[3]=1;   foundP4id=0;
 thisSearchRegion[0] = dataStore.searchRegionP4[0];
 thisSearchRegion[1] = dataStore.searchRegionP4[1];
 if(thisSearchRegion[0]<(centers[2]+5)){ thisSearchRegion[0] = (centers[2]+10); }
 while(foundP4id<3){
      thisPeak=thisSearchRegion[0];
      for(i=thisSearchRegion[0]; i<(thisSearchRegion[1]); i++){
         if((i > (centers[0]-5) && i < (centers[0]+5)) || (i >  (centers[1]-5) && i < (centers[1]+5)) || (i >  (centers[2]-5) && i < (centers[2]+5))){ continue; }
         if(foundP4id>0 && i > (foundP4peaks[0]-5) && i < (foundP4peaks[0]+5)){ continue; }
         if(foundP4id>1 && i > (foundP4peaks[1]-5) && i < (foundP4peaks[1]+5)){ continue; }
         localPBG = (data[i-4]+data[i-3]+data[i-2]+data[i-1]+data[i]+data[i+1]+data[i+2]+data[i+3]) / (data[i-8]+data[i-7]+data[i-6]+data[i-5]+data[i+5]+data[i+6]+data[i+7]+data[i+8]);
         if(data[i] > data[thisPeak] && localPBG>0.5){
           thisPeak=i;
         }
      }

 if(thisPeak>thisSearchRegion[0]){
   foundP4peaks[foundP4id]=thisPeak;
   foundP4id++;
 }else if(foundP4id<1){
         thisSearchRegion[0] += 10;
         if(thisSearchRegion[0]>(thisSearchRegion[1] - 20)){
           foundP4id=3;
          }
         }else{
               foundP4peaks[2]=foundP4peaks[1]=foundP4peaks[0];  foundP4id=3; }
         }
 centers[3]=foundP4peaks[0];




// Perform sanity checks on the Guessed peaks here.
// There are some intense background peaks close by which may be found erroneously
// First predict and check the position of Peak 1 and 4 based on a linear calibration using only Peak 2 and 3
var Epeak1 = document.getElementById('peak1').value;
var Epeak2 = document.getElementById('peak2').value;
var Epeak3 = document.getElementById('peak3').value;
var Epeak4 = document.getElementById('peak4').value;

var refitP1 = 1;
var refitP2 = 1;
var refitP3 = 1;
var refitP4 = 1;
var NumAttempts=0;

// Test all combinations of the Peaks identified within the search regions to find the correct set
var breakForLoop=0;
for(i=0; i<3; i++){

for(j=0; j<3; j++){
if(foundP2peaks[j]<(foundP1peaks[i]+5)){ continue; }

for(k=0; k<3; k++){
if(foundP3peaks[k]<(foundP2peaks[j]+5)){ continue; }
if(foundP3peaks[k]<(foundP1peaks[i]+5)){ continue; }

for(l=0; l<3; l++){
if(foundP4peaks[l]<(foundP3peaks[k]+5)){ continue; }
if(foundP4peaks[l]<(foundP2peaks[j]+5)){ continue; }
if(foundP4peaks[l]<(foundP1peaks[i]+5)){ continue; }

var ratioDiffP12 = Math.abs((foundP1peaks[i] / foundP2peaks[j])-(Epeak1 / Epeak2));
var ratioDiffP13 = Math.abs((foundP1peaks[i] / foundP3peaks[k])-(Epeak1 / Epeak3));
var ratioDiffP14 = Math.abs((foundP1peaks[i] / foundP4peaks[l])-(Epeak1 / Epeak4));
var ratioDiffP23 = Math.abs((foundP2peaks[j] / foundP3peaks[k])-(Epeak2 / Epeak3));
var ratioDiffP24 = Math.abs((foundP2peaks[j] / foundP4peaks[l])-(Epeak2 / Epeak4));
var ratioDiffP34 = Math.abs((foundP3peaks[k] / foundP4peaks[l])-(Epeak3 / Epeak4));


// Test if this combination of Peaks identified are correct
if((ratioDiffP12 < 0.005)
&& (ratioDiffP13 < 0.005)
&& (ratioDiffP14 < 0.005)
&& (ratioDiffP23 < 0.005)
&& (ratioDiffP24 < 0.005)
&& (ratioDiffP34 < 0.005)
){
refitP1 = refitP2 = refitP3 = refitP4 = 0;
centers[0] = foundP1peaks[i];
centers[1] = foundP2peaks[j];
centers[2] = foundP3peaks[k];
centers[3] = foundP4peaks[l];
breakForLoop=1;
}
if(breakForLoop){ break; }
}//end of l for
if(breakForLoop){ break; }
}//end of k for
if(breakForLoop){ break; }
}//end of j for
if(breakForLoop){ break; }
}//end of i for

if(!breakForLoop){
/*
console.log('\n\nAn optimal solution was not found for '+spectrumName);
console.log('Search regions: '+dataStore.searchRegionP1[0]+'-'+dataStore.searchRegionP1[1]+', '+dataStore.searchRegionP2[0]+'-'+dataStore.searchRegionP2[1]+', '+dataStore.searchRegionP3[0]+'-'+dataStore.searchRegionP3[1]+', '+dataStore.searchRegionP4[0]+'-'+dataStore.searchRegionP4[1]);
console.log('Found peaks are: '+foundP1peaks+', '+foundP2peaks+', '+foundP3peaks+', '+foundP4peaks);
*/
var breakForLoop=0;
for(i=0; i<3; i++){

for(j=0; j<3; j++){
if(foundP2peaks[j]<(foundP1peaks[i]+5)){ continue; }

for(k=0; k<3; k++){
if(foundP3peaks[k]<(foundP2peaks[j]+5)){ continue; }

for(l=0; l<3; l++){
if(foundP4peaks[l]<(foundP3peaks[k]+5)){ continue; }

var ratioDiffP12 = Math.abs((foundP1peaks[i] / foundP2peaks[j])-(Epeak1 / Epeak2));
var ratioDiffP13 = Math.abs((foundP1peaks[i] / foundP3peaks[k])-(Epeak1 / Epeak3));
var ratioDiffP14 = Math.abs((foundP1peaks[i] / foundP4peaks[l])-(Epeak1 / Epeak4));
var ratioDiffP23 = Math.abs((foundP2peaks[j] / foundP3peaks[k])-(Epeak2 / Epeak3));
var ratioDiffP24 = Math.abs((foundP2peaks[j] / foundP4peaks[l])-(Epeak2 / Epeak4));
var ratioDiffP34 = Math.abs((foundP3peaks[k] / foundP4peaks[l])-(Epeak3 / Epeak4));
/*
console.log('Test '+i+', '+j+', '+k+', '+l+', '+foundP1peaks[i]+', '+foundP2peaks[j]+', '+foundP3peaks[k]+', '+foundP4peaks[l]);
console.log('Ratio12='+ratioDiffP12);
console.log('Ratio13='+ratioDiffP13);
console.log('Ratio14='+ratioDiffP14);
console.log('Ratio23='+ratioDiffP23);
console.log('Ratio24='+ratioDiffP24);
console.log('Ratio34='+ratioDiffP34);
*/
// Test if this combination of Peaks identified are correct
if((ratioDiffP12 < 0.005)
&& (ratioDiffP13 < 0.005)
&& (ratioDiffP14 < 0.005)
&& (ratioDiffP23 < 0.005)
&& (ratioDiffP24 < 0.005)
&& (ratioDiffP34 < 0.005)
){
refitP1 = refitP2 = refitP3 = refitP4 = 0;
centers[0] = foundP1peaks[i];
centers[1] = foundP2peaks[j];
centers[2] = foundP3peaks[k];
centers[3] = foundP4peaks[l];
breakForLoop=1;
}
if(breakForLoop){ break; }
}//end of l for
if(breakForLoop){ break; }
}//end of k for
if(breakForLoop){ break; }
}//end of j for
if(breakForLoop){ break; }
}//end of i for

}

// Define the Regions of Interest for the full peak fitting based on the peaks found
      if(dataStore.detectorType == 'LaBr3'){
        ROIwidth = 20;
            dataStore.ROI[spectrumName] = {
                "ROIlower":  [centers[0] - 10, centers[0] + 10],
                "ROImiddle": [centers[1] - 10, centers[1] + 10],
                "ROIupper":  [centers[2] - 15, centers[2] + 15],
                "ROItop":    [centers[3] - 30, centers[3] + 30]
            }
          }else{
              ROIwidth = 4;
                dataStore.ROI[spectrumName] = {
                    "ROIlower":  [centers[0] - ROIwidth, centers[0] + ROIwidth],
                    "ROImiddle": [centers[1] - ROIwidth, centers[1] + ROIwidth],
                    "ROIupper":  [centers[2] - ROIwidth, centers[2] + ROIwidth],
                    "ROItop":    [centers[3] - ROIwidth, centers[3] + ROIwidth]
                }
          }
},

        this.fitCallback = function(center, width, amplitude, intercept, slope){
            //after fitting, log the fit results, as well as any modification made to the ROI by the fitting algortihm
            //also update table
            //<center>: number; center of gaussian peak
            //<width>: number; width of peak
            //<amplitude>: number; amplitude of peak
            //<intercept>: number; intercept of linear background beneath peak
            //<slope>: number; slope of linear background
            //this: gainMatchReport object

            var lowPeak = document.getElementById('fitLow');
            var midPeak = document.getElementById('fitMid');
            var highPeak = document.getElementById('fitHigh');
            var vhiPeak = document.getElementById('fitvHi');
            var viewerName = dataStore.plots[0];
            var thisPlotName = dataStore.currentPlot;
            if(thisPlotName.includes(':')){
               thisPlotName = thisPlotName.split(':')[1].slice(0,10);
            }else{
               thisPlotName = thisPlotName.slice(0,10);
            }

            if(!dataStore.fitResults[dataStore.currentPlot])
                dataStore.fitResults[dataStore.currentPlot] = [];

            //keep track of fit results
            dataStore.fitResults[dataStore.currentPlot][dataStore.currentPeak] = [amplitude, center, width, intercept, slope]

            //convenient to arrange resolution data here
            if(dataStore.currentPeak == 0)
                dataStore.lowPeakResolution[dataStore.THESEdetectors.indexOf(thisPlotName)] = width;
            else if(dataStore.currentPeak == 1)
                dataStore.midPeakResolution[dataStore.THESEdetectors.indexOf(thisPlotName)] = width;
            else if(dataStore.currentPeak == 2)
                dataStore.highPeakResolution[dataStore.THESEdetectors.indexOf(thisPlotName)] = width;
            else if(dataStore.currentPeak == 3)
                dataStore.vhiPeakResolution[dataStore.THESEdetectors.indexOf(thisPlotName)] = width;

            if(dataStore.currentPeak == 0){
                dataStore.ROI[dataStore.currentPlot].ROIlower[0] = dataStore.viewers[viewerName].FitLimitLower;
                dataStore.ROI[dataStore.currentPlot].ROIlower[1] = dataStore.viewers[viewerName].FitLimitUpper;
            } else if(dataStore.currentPeak == 1){
                dataStore.ROI[dataStore.currentPlot].ROImiddle[0] = dataStore.viewers[viewerName].FitLimitLower;
                dataStore.ROI[dataStore.currentPlot].ROImiddle[1] = dataStore.viewers[viewerName].FitLimitUpper;
            } else if(dataStore.currentPeak == 2){
                dataStore.ROI[dataStore.currentPlot].ROIupper[0] = dataStore.viewers[viewerName].FitLimitLower;
                dataStore.ROI[dataStore.currentPlot].ROIupper[1] = dataStore.viewers[viewerName].FitLimitUpper;
            } else{
                dataStore.ROI[dataStore.currentPlot].ROItop[0] = dataStore.viewers[viewerName].FitLimitLower;
                dataStore.ROI[dataStore.currentPlot].ROItop[1] = dataStore.viewers[viewerName].FitLimitUpper;
            }

/*
            // Calculate peak area here
            console.log(dataStore.currentPlot + 'amplitude,center,width,intercept,slope: '+ amplitude +','+center+','+ width +','+ intercept +','+ slope);
            var grossArea = 0,
                netArea = 0,
                integral = 0,
                functionVals = [],
                i, x, sigmas = 5, stepSize = 0.01;
            //calculate peak area in excess of background, for <sigmas> up and down.
            for(i=0; i<2*sigmas*width/stepSize; i++){
                x = center - sigmas*width + i*stepSize
                functionVals.push( gauss(amplitude, center, width, x)*stepSize )
                integral = functionVals.integrate()
            }
            netArea = integral.toFixed(2);
            console.log(dataStore.currentPlot + ', Peak '+dataStore.currentPeak+', Area = '+grossArea);
*/

            //update table
            this.updateTable(dataStore.currentPlot);

            //update plot
            dataStore.viewers[dataStore.plots[0]].plotData();

            //update resolution plot
            this.reconstructResolutionData();

            //update residuals plots
            if(dataStore.currentPeak==3){
              this.reconstructResidualsData(dataStore.currentPlot,dataStore.THESEdetectors.indexOf(thisPlotName));
              this.reconstructMidasResidualsData(dataStore.currentPlot,dataStore.THESEdetectors.indexOf(thisPlotName));
             }

            //disengage fit mode buttons
            if( parseInt(lowPeak.getAttribute('engaged'),10) == 1)
                lowPeak.onclick();
            if( parseInt(midPeak.getAttribute('engaged'),10) == 1)
                midPeak.onclick();
            if( parseInt(highPeak.getAttribute('engaged'),10) == 1)
                highPeak.onclick();
            if( parseInt(vhiPeak.getAttribute('engaged'),10) == 1)
                vhiPeak.onclick();

        },

        this.updateTable = function(spectrum){
            //update the report table with whatever is currently in the dataStore
            //recall dataStore.fitReults[plotTitle] = [[amplitude, center, width, slope, intercept],[...]], for [low energy, high energy].
            //<spectrumName>: string; name of spectrum, per names from analyzer
            //this: gainMatchReport object

            var calibration;
            var thisPlotName = spectrum;
            if(thisPlotName.includes(':')){
               thisPlotName = thisPlotName.split(':')[1].slice(0,10);
            }else{
               thisPlotName = thisPlotName.slice(0,10);
            }

            if(Array.isArray(dataStore.fitResults[spectrum][0]))
                document.getElementById(this.wrapID + thisPlotName + 'chan1').innerHTML = dataStore.fitResults[spectrum][0][1].toFixed(3);
            if(Array.isArray(dataStore.fitResults[spectrum][1]))
                document.getElementById(this.wrapID + thisPlotName + 'chan2').innerHTML = dataStore.fitResults[spectrum][1][1].toFixed(3);
            if(Array.isArray(dataStore.fitResults[spectrum][2]))
                document.getElementById(this.wrapID + thisPlotName + 'chan3').innerHTML = dataStore.fitResults[spectrum][2][1].toFixed(3);
            if(Array.isArray(dataStore.fitResults[spectrum][3]))
                document.getElementById(this.wrapID + thisPlotName + 'chan4').innerHTML = dataStore.fitResults[spectrum][3][1].toFixed(3);

            if(Array.isArray(dataStore.fitResults[spectrum][0]) && Array.isArray(dataStore.fitResults[spectrum][1]) && Array.isArray(dataStore.fitResults[spectrum][2]) && Array.isArray(dataStore.fitResults[spectrum][3])){
              if(dataStore.detectorType == 'HPGe' || dataStore.detectorType == 'LaBr3'){
                // Quadratic fit for HPGe
                calibration = this.calculateQuadratic(dataStore.fitResults[spectrum][0][1], dataStore.fitResults[spectrum][1][1], dataStore.fitResults[spectrum][2][1], dataStore.fitResults[spectrum][3][1]);
                document.getElementById(this.wrapID + thisPlotName + 'offset').innerHTML = calibration[0].toFixed(8);
                document.getElementById(this.wrapID + thisPlotName + 'gain').innerHTML = calibration[1].toFixed(8);
                document.getElementById(this.wrapID + thisPlotName + 'quad').innerHTML = calibration[2].toFixed(8);
                dataStore.fitResults[spectrum][4] = calibration
              }else if(dataStore.detectorType = 'PACES'){
                // Linear fit for PACES
                calibration = this.calculateLinear(dataStore.fitResults[spectrum][0][1], dataStore.fitResults[spectrum][1][1], dataStore.fitResults[spectrum][2][1], dataStore.fitResults[spectrum][3][1]);
                calibration.push(0.0); // add the quadratic term
                 document.getElementById(this.wrapID + thisPlotName + 'offset').innerHTML = calibration[0].toFixed(8);
                  document.getElementById(this.wrapID + thisPlotName + 'gain').innerHTML = calibration[1].toFixed(8);
                 document.getElementById(this.wrapID + thisPlotName + 'quad').innerHTML = 0.0;
                  dataStore.fitResults[spectrum][4] = calibration
                  console.log(dataStore.fitResults);
              }
            }

            //highlight suspicious rows
            this.whatsNormal();
            this.highlightOutliers();

        },

                this.calculateLine = function(lowBin, highBin){
                    //given the positions of the low bin and high bin, return [intercept, slope] defining
                    //a striaght calibration line using the energies reported in the input.
                    //lowBin: number; center of low energy peak in bins
                    //highBin: number; center of high energy peak in bins
                    //this: gainMatchReport object

                    var lowEnergy = document.getElementById('peak1').value
                    var highEnergy = document.getElementById('peak2').value
                    var slope, intercept;

                    slope = (lowEnergy - highEnergy) / (lowBin - highBin);
                    intercept = lowEnergy - slope*lowBin

                    return [intercept, slope]

                },

                        this.calculateLinear = function(lowBin, midBin, highBin, vhiBin){
                            //given the positions of the low bin and high bin, return [intercept, slope] defining
                            //a striaght calibration line using the energies reported in the input.
                            //lowBin: number; center of low energy peak in bins
                            //highBin: number; center of high energy peak in bins
                            //vhiBin: number; center of top energy peak in bins
                            //this: gainMatchReport object

                                        var lowEnergy = document.getElementById('peak1').value
                                        var midEnergy = document.getElementById('peak2').value
                                        var highEnergy = document.getElementById('peak3').value
                                        var vhiEnergy = document.getElementById('peak4').value
                            var slope, intercept;

                            if(lowBin>0 && midBin>0 && highBin>0 && vhiBin>0){

                            data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
                            }else if(isNaN(lowBin) || lowBin<=0){
                            data = [[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
                            }else if(isNaN(midBin) || midBin<=0){
                            data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
                            }else if(isNaN(highBin) || highBin<=0){
                            data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
                            }else if(isNaN(vhiBin) || vhiBin<=0){
                            data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)]];
                            }else{ data = null;}

                            // Hats off to Tom Alexander, https://github.com/Tom-Alexander/regression-js
                            const result = regression.linear(data);
                            console.log(result);

                            slope = result.equation[0];
                            intercept = result.equation[1];

                                        return [intercept, slope]

                        },

        this.calculateQuadratic = function(lowBin, midBin, highBin, vhiBin){
            //given the positions of the low bin and high bin, return [intercept, slope] defining
            //a striaght calibration line using the energies reported in the input.
            //lowBin: number; center of low energy peak in bins
            //highBin: number; center of high energy peak in bins
            //vhiBin: number; center of top energy peak in bins
            //this: gainMatchReport object

            var lowEnergy = document.getElementById('peak1').value
            var midEnergy = document.getElementById('peak2').value
            var highEnergy = document.getElementById('peak3').value
            var vhiEnergy = document.getElementById('peak4').value
            var quad, slope, intercept;
            var data = [];

if(lowBin>0 && midBin>0 && highBin>0 && vhiBin>0){

data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
}else if(isNaN(lowBin) || lowBin<=0){
data = [[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
}else if(isNaN(midBin) || midBin<=0){
data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(highBin), parseFloat(highEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
}else if(isNaN(highBin) || highBin<=0){
data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(vhiBin), parseFloat(vhiEnergy)]];
}else if(isNaN(vhiBin) || vhiBin<=0){
data = [[parseFloat(lowBin), parseFloat(lowEnergy)],[parseFloat(midBin), parseFloat(midEnergy)],[parseFloat(highBin), parseFloat(highEnergy)]];
}else{ data = null;}

// Hats off to Tom Alexander, https://github.com/Tom-Alexander/regression-js
const result = regression.polynomial(data, { order: 2, precision: 20 });
//console.log(result);

quad = result.equation[0];
slope = result.equation[1];
intercept = result.equation[2];

            return [intercept, slope, quad]

        },





        this.whatsNormal = function(){
            //identifies the mean and SD of the calibration quad, slope and intercept across all detectors

            var i, meanQuad = 0, sqMeanQuad = 0, meanSlope = 0, sqMeanSlope = 0, meanIntercept = 0, sqMeanIntercept = 0, sdQuad, sdSlope, sdIntercept,
                keys = Object.keys(dataStore.fitResults),
                numIntercept = 0, numSlope = 0, numQuad = 0

            for(i=0; i<keys.length; i++){
                if(dataStore.fitResults[keys[i]][4] && dataStore.fitResults[keys[i]][4][0]){
                    meanIntercept += dataStore.fitResults[keys[i]][2][0];
                    sqMeanIntercept += Math.pow(dataStore.fitResults[keys[i]][4][0], 2);
                    numIntercept++;
                }
                if(dataStore.fitResults[keys[i]][4] && dataStore.fitResults[keys[i]][4][1]){
                    meanSlope += dataStore.fitResults[keys[i]][2][1];
                    sqMeanSlope += Math.pow(dataStore.fitResults[keys[i]][4][1], 2);
                    numSlope++;
                }
                if(dataStore.fitResults[keys[i]][4] && dataStore.fitResults[keys[i]][4][2]){
                    meanQuad += dataStore.fitResults[keys[i]][2][2];
                    sqMeanQuad += Math.pow(dataStore.fitResults[keys[i]][4][2], 2);
                    numQuad++;
                }
            }

            meanIntercept /= numIntercept;
            sqMeanIntercept /= numIntercept;
            meanSlope /= numSlope;
            sqMeanSlope /= numSlope;
            meanQuad /= numQuad;
            sqMeanQuad /= numQuad;

            sdIntercept = Math.sqrt(sqMeanIntercept - Math.pow(meanIntercept,2));
            sdSlope = Math.sqrt(sqMeanSlope - Math.pow(meanSlope,2));
            sdQuad = Math.sqrt(sqMeanQuad - Math.pow(meanQuad,2));

            dataStore.meanCalib = [meanIntercept, meanSlope, meanQuad];
            dataStore.sdCalib = [sdIntercept, sdSlope, sdQuad];
        },

        this.highlightOutliers = function(){
            //step through the fit results, and highlight table rows corresponding to wacky channels
            //this: gainMatchReport object

            var i;
            var keys = Object.keys(dataStore.fitResults);
            var thisKey;

            for(i=0; i<keys.length; i++){
                 if(!dataStore.fitResults[keys[i]][4]){ continue; }

                 thisKey = keys[i];
                 if(thisKey.includes(':')){
                   thisKey = thisKey.split(':')[1].slice(0,10);
                 }else{
                   thisKey = thisKey.slice(0,10);
                 }


                     if( dataStore.fitResults[keys[i]][0] && dataStore.fitResults[keys[i]][1] && dataStore.fitResults[keys[i]][2] && (
                        dataStore.fitResults[keys[i]][4][0] > dataStore.meanCalib[0] + dataStore.sdCalib[0]*3
                        || dataStore.fitResults[keys[i]][4][0] < dataStore.meanCalib[0] - dataStore.sdCalib[0]*3
                        || Math.abs(dataStore.fitResults[keys[i]][4][0]) > 10
                        || dataStore.fitResults[keys[i]][4][1] > dataStore.meanCalib[1] + dataStore.sdCalib[1]*3
                        || dataStore.fitResults[keys[i]][4][1] < dataStore.meanCalib[1] - dataStore.sdCalib[1]*3
                        || dataStore.fitResults[keys[i]][4][2] > dataStore.meanCalib[2] + dataStore.sdCalib[2]*3
                        || dataStore.fitResults[keys[i]][4][2] < dataStore.meanCalib[2] - dataStore.sdCalib[2]*3
                        || Math.abs(dataStore.fitResults[keys[i]][4][2]) > 0.00001
                    )
                ){
                    document.getElementById(this.wrapID + thisKey + 'row').setAttribute('style', 'background-color: #FF0000;');
                    document.getElementById(thisKey + 'write').checked = false;
                 } else if(isNaN(dataStore.fitResults[keys[i]][0][1])
                           || isNaN(dataStore.fitResults[keys[i]][1][1])
                           || isNaN(dataStore.fitResults[keys[i]][2][1])
                           || isNaN(dataStore.fitResults[keys[i]][3][1])  ){
                    document.getElementById(this.wrapID + thisKey + 'row').setAttribute('style', 'background-color: #F28C28;');
                    document.getElementById(thisKey + 'write').checked = false;
                } else{
                    document.getElementById(this.wrapID + thisKey + 'row').setAttribute('style', '');
                    document.getElementById(thisKey + 'write').checked = true;
                }
            }
        },

        this.reconstructResolutionData = function(){
            //arrange the latest resolution info for representation in the dygraph.

            var i, evt, detectorIndex = [],
            flags = [];
            flags.fillN(0, dataStore.THESEdetectors.length)

            for(i=0; i<dataStore.THESEdetectors.length; i++){
                detectorIndex[i] = i;
            }

            dataStore.resolutionData = arrangePoints(detectorIndex, [dataStore.lowPeakResolution, dataStore.midPeakResolution, dataStore.highPeakResolution, dataStore.vhiPeakResolution], flags );
            dispatcher({ 'data': dataStore.resolutionData }, 'updateDyData0');
        },

        this.reconstructResidualsData = function(currentSpectrum,currentDetNum){
            // First determine the residuals by applying the calibration coefficients to the fitted centroid, then comparing it to the literature energy.
            // Save the residuals data to the dataStore, then
            //arrange the latest residual info for representation in the dygraph.

             var thisOffset = dataStore.fitResults[currentSpectrum][4][0];
             var thisGain = dataStore.fitResults[currentSpectrum][4][1];
             var thisQuadratic = dataStore.fitResults[currentSpectrum][4][2];

             for(currentPeak=0; currentPeak<4; currentPeak++){
               var peakIndex = currentPeak+1;
               var literatureEnergy = document.getElementById('peak'+peakIndex).value;


               // Save the data for the residuals plots
               thisCentroid = dataStore.fitResults[currentSpectrum][currentPeak][1];
               dataStore.residualsData[peakIndex][currentDetNum] = literatureEnergy - ( thisOffset  + (thisGain*thisCentroid) + (thisQuadratic*thisCentroid*thisCentroid) );

               var i, evt, detectorIndex = [],
               flags = [];
               flags.fillN(0, dataStore.THESEdetectors.length)

               for(i=0; i<dataStore.THESEdetectors.length; i++){
                  detectorIndex[i] = i;
               }

               // Update the Y axis scale if needed
               if(dataStore.residualsData[peakIndex][currentDetNum] < (0.75 * dataStore.YAxisMinValue[peakIndex][0])){
                 var newYAxisMinValue = dataStore.residualsData[peakIndex][currentDetNum] * 1.33;
                 dataStore.YAxisMinValue[1][0] = dataStore.YAxisMinValue[2][0] = dataStore.YAxisMinValue[3][0] = dataStore.YAxisMinValue[4][0] = newYAxisMinValue;
               }
               if(dataStore.residualsData[peakIndex][currentDetNum] > (0.75 * dataStore.YAxisMaxValue[peakIndex][0])){
                 var newYAxisMaxValue = dataStore.residualsData[peakIndex][currentDetNum] * 1.33;
                 dataStore.YAxisMaxValue[1][0] = dataStore.YAxisMaxValue[2][0] = dataStore.YAxisMaxValue[3][0] = dataStore.YAxisMaxValue[4][0] = newYAxisMaxValue;
               }

               dataStore.dataplotData[peakIndex] = arrangePoints(detectorIndex, [dataStore.residualsData[peakIndex]], flags );
               var eventString = 'updateDyData'+peakIndex;

               dispatcher({ 'data': dataStore.dataplotData[peakIndex] }, eventString);
            }

            // Update the mean and standard deviation of the dataset
            this.calculateResidualsSD();
        },

        this.reconstructMidasResidualsData = function(currentSpectrum,currentDetNum){
            // First determine the residuals by applying the calibration coefficients from the server to the fitted centroid, then comparing it to the literature energy.
            // Save the residuals data to the dataStore, then
            //arrange the latest residual info for representation in the dygraph.

            var thisPlotName = currentSpectrum;
            if(thisPlotName.includes(':')){
               thisPlotName = thisPlotName.split(':')[1];
            }

             var thisOffset = dataStore.midasCalibration[thisPlotName][0];
             var thisGain = dataStore.midasCalibration[thisPlotName][1];
             var thisQuadratic = dataStore.midasCalibration[thisPlotName][2];

             for(currentPeak=0; currentPeak<4; currentPeak++){
               var peakIndex = currentPeak+1;
               var literatureEnergy = document.getElementById('peak'+peakIndex).value;
               peakIndex +=4;

               // Save the data for the residuals plots
               thisCentroid = dataStore.fitResults[currentSpectrum][currentPeak][1];
               dataStore.residualsData[peakIndex][currentDetNum] = literatureEnergy - ( thisOffset  + (thisGain*thisCentroid) + (thisQuadratic*thisCentroid*thisCentroid) );

               var i, evt, detectorIndex = [],
               flags = [];
               flags.fillN(0, dataStore.THESEdetectors.length)

               for(i=0; i<dataStore.THESEdetectors.length; i++){
                  detectorIndex[i] = i;
               }

               // Update the Y axis scale if needed
               if(dataStore.residualsData[peakIndex][currentDetNum] < (0.75 * dataStore.YAxisMinValue[peakIndex][0])){
                 var newYAxisMinValue = dataStore.residualsData[peakIndex][currentDetNum] * 1.33;
                 dataStore.YAxisMinValue[5][0] = dataStore.YAxisMinValue[6][0] = dataStore.YAxisMinValue[7][0] = dataStore.YAxisMinValue[8][0] = newYAxisMinValue;
               }
               if(dataStore.residualsData[peakIndex][currentDetNum] > (0.75 * dataStore.YAxisMaxValue[peakIndex][0])){
                 var newYAxisMaxValue = dataStore.residualsData[peakIndex][currentDetNum] * 1.33;
                 dataStore.YAxisMaxValue[5][0] = dataStore.YAxisMaxValue[6][0] = dataStore.YAxisMaxValue[7][0] = dataStore.YAxisMaxValue[8][0] = newYAxisMaxValue;
               }

               dataStore.dataplotData[peakIndex] = arrangePoints(detectorIndex, [dataStore.residualsData[peakIndex]], flags );
               var eventString = 'updateDyData'+peakIndex;
               dispatcher({ 'data': dataStore.dataplotData[peakIndex] }, eventString);
            }

            // Update the mean and standard deviation of the dataset
            this.calculateMidasResidualsSD();
        },

        this.calculateResidualsSD = function(){
            //identifies the mean and SD of the residuals across all detectors

            var i, meanP1 = 0, sqMeanP1 = 0, meanP2 = 0, sqMeanP2 = 0, meanP3 = 0, sqMeanP3 = 0, meanP4 = 0, sqMeanP4 = 0,
                numP1 = 0, numP2 = 0, numP3 = 0, numP4 = 0;

            for(i=0; i<dataStore.residualsData.length; i++){
                if(dataStore.residualsData[1][i]){
                    meanP1 += dataStore.residualsData[1][i];
                    sqMeanP1 += Math.pow(dataStore.residualsData[1][i],2);
                    numP1++;
                }
                if(dataStore.residualsData[2][i]){
                    meanP2 += dataStore.residualsData[2][i];
                    sqMeanP2 += Math.pow(dataStore.residualsData[2][i],2);
                    numP2++;
                }
                if(dataStore.residualsData[3][i]){
                    meanP3 += dataStore.residualsData[3][i];
                    sqMeanP3 += Math.pow(dataStore.residualsData[3][i],2);
                    numP3++;
                }
                if(dataStore.residualsData[4][i]){
                    meanP4 += dataStore.residualsData[4][i];
                    sqMeanP4 += Math.pow(dataStore.residualsData[4][i],2);
                    numP4++;
                }
            }

            meanP1 /= numP1;
            meanP2 /= numP2;
            meanP3 /= numP3;
            meanP4 /= numP4;

            sqMeanP1 /= numP1;
            sqMeanP2 /= numP2;
            sqMeanP3 /= numP3;
            sqMeanP4 /= numP4;


            sdMeanP1 = Math.sqrt(sqMeanP1 - Math.pow(meanP1,2));
            sdMeanP2 = Math.sqrt(sqMeanP2 - Math.pow(meanP2,2));
            sdMeanP3 = Math.sqrt(sqMeanP3 - Math.pow(meanP3,2));
            sdMeanP4 = Math.sqrt(sqMeanP4 - Math.pow(meanP4,2));

            dataStore.residualsDataMean = [0, meanP1, meanP2, meanP3, meanP4];
            dataStore.residualsDataSD = [0, sqMeanP1, sqMeanP2, sqMeanP3, sqMeanP4];

            document.getElementById('residualP1newText').innerHTML  = 'Peak1 residuals: Mean: '+meanP1.toFixed(3)+', Standard Deviation: '+sdMeanP1.toFixed(3)+' keV';
            document.getElementById('residualP2newText').innerHTML  = 'Peak2 residuals: Mean: '+meanP2.toFixed(3)+', Standard Deviation: '+sdMeanP2.toFixed(3)+' keV';
            document.getElementById('residualP3newText').innerHTML  = 'Peak3 residuals: Mean: '+meanP3.toFixed(3)+', Standard Deviation: '+sdMeanP3.toFixed(3)+' keV';
            document.getElementById('residualP4newText').innerHTML  = 'Peak4 residuals: Mean: '+meanP4.toFixed(3)+', Standard Deviation: '+sdMeanP4.toFixed(3)+' keV';
        },

        this.calculateMidasResidualsSD = function(){
            //identifies the mean and SD of the residuals across all detectors

            var i, meanP1 = 0, sqMeanP1 = 0, meanP2 = 0, sqMeanP2 = 0, meanP3 = 0, sqMeanP3 = 0, meanP4 = 0, sqMeanP4 = 0,
                numP1 = 0, numP2 = 0, numP3 = 0, numP4 = 0;

            for(i=0; i<dataStore.residualsData.length; i++){
                if(dataStore.residualsData[5][i]){
                    meanP1 += dataStore.residualsData[5][i];
                    sqMeanP1 += Math.pow(dataStore.residualsData[5][i],2);
                    numP1++;
                }
                if(dataStore.residualsData[6][i]){
                    meanP2 += dataStore.residualsData[6][i];
                    sqMeanP2 += Math.pow(dataStore.residualsData[6][i],2);
                    numP2++;
                }
                if(dataStore.residualsData[7][i]){
                    meanP3 += dataStore.residualsData[7][i];
                    sqMeanP3 += Math.pow(dataStore.residualsData[7][i],2);
                    numP3++;
                }
                if(dataStore.residualsData[8][i]){
                    meanP4 += dataStore.residualsData[8][i];
                    sqMeanP4 += Math.pow(dataStore.residualsData[8][i],2);
                    numP4++;
                }
            }

            meanP1 /= numP1;
            meanP2 /= numP2;
            meanP3 /= numP3;
            meanP4 /= numP4;

            sqMeanP1 /= numP1;
            sqMeanP2 /= numP2;
            sqMeanP3 /= numP3;
            sqMeanP4 /= numP4;


            sdMeanP1 = Math.sqrt(sqMeanP1 - Math.pow(meanP1,2));
            sdMeanP2 = Math.sqrt(sqMeanP2 - Math.pow(meanP2,2));
            sdMeanP3 = Math.sqrt(sqMeanP3 - Math.pow(meanP3,2));
            sdMeanP4 = Math.sqrt(sqMeanP4 - Math.pow(meanP4,2));

            dataStore.residualsDataMean = [0, meanP1, meanP2, meanP3, meanP4];
            dataStore.residualsDataSD = [0, sqMeanP1, sqMeanP2, sqMeanP3, sqMeanP4];

            document.getElementById('residualP1midText').innerHTML  = 'Peak1 residuals: Mean: '+meanP1.toFixed(3)+', Standard Deviation: '+sdMeanP1.toFixed(3)+' keV';
            document.getElementById('residualP2midText').innerHTML  = 'Peak2 residuals: Mean: '+meanP2.toFixed(3)+', Standard Deviation: '+sdMeanP2.toFixed(3)+' keV';
            document.getElementById('residualP3midText').innerHTML  = 'Peak3 residuals: Mean: '+meanP3.toFixed(3)+', Standard Deviation: '+sdMeanP3.toFixed(3)+' keV';
            document.getElementById('residualP4midText').innerHTML  = 'Peak4 residuals: Mean: '+meanP4.toFixed(3)+', Standard Deviation: '+sdMeanP4.toFixed(3)+' keV';
        },

        this.updateEnergies = function(){
            //callback for the calibration source dropdown; updates energy input boxes with standard values
            //this: gainMatchReport object

            var calibrationSourceName = getSelected(this.wrapID + 'calibrationSource');

            // Find the index number for the source information for this sourceType
            var index = dataStore.sourceInfo.map(function(e) { return e.name; }).indexOf(calibrationSourceName);

            // Set the peak energies for this source
            document.getElementById('peak1').value  = dataStore.sourceInfo[index].lowEnergy;
            document.getElementById('peak2').value  = dataStore.sourceInfo[index].midEnergy;
            document.getElementById('peak3').value = dataStore.sourceInfo[index].highEnergy;
            document.getElementById('peak4').value  = dataStore.sourceInfo[index].vhiEnergy;

        },

        this.customEnergy = function(){
            //callback for changing the calibration energies to custom values
            //this: gainMatchReport object

            var i, keys = Object.keys(dataStore.fitResults)
            var defaultSources = document.getElementById(this.wrapID + 'calibrationSource')

            defaultSources.value = 'custom'
        },

        this.toggleFitMode = function(){
            //gain matcher needs special fit controls for convenience
            //this: fit mode engage button element

            var viewerName = dataStore.plots[0];

            if(parseInt(this.getAttribute('engaged'),10) == 0){
                dataStore.viewers[viewerName].setupFitMode();
                this.setAttribute('engaged', 1);
                if(this.id == 'fitLow')
                    document.getElementById('refitLoBadge').classList.add('red-text')
                if(this.id == 'fitMid')
                    document.getElementById('refitMidBadge').classList.add('red-text')
                if(this.id == 'fitHigh')
                    document.getElementById('refitHiBadge').classList.add('red-text')
                if(this.id == 'fitvHi')
                    document.getElementById('refitvHiBadge').classList.add('red-text')
            }
            else{
                dataStore.viewers[viewerName].leaveFitMode();
                this.setAttribute('engaged', 0);
                if(this.id == 'fitLow')
                    document.getElementById('refitLoBadge').classList.remove('red-text')
                if(this.id == 'fitMid')
                    document.getElementById('refitMidBadge').classList.remove('red-text')
                if(this.id == 'fitHigh')
                    document.getElementById('refitHiBadge').classList.remove('red-text')
                if(this.id == 'fitvHi')
                    document.getElementById('refitvHiBadge').classList.remove('red-text')
            }

            if(this.id == 'fitLow')
                dataStore.currentPeak = 0
            else if(this.id == 'fitMid')
                dataStore.currentPeak = 1
             else if(this.id == 'fitHigh')
                dataStore.currentPeak = 2
            else
                dataStore.currentPeak = 3

        },

        this.toggleAnalyzerwrite = function(){
            //toggle Analyzer writing permission.

            var allowed = document.getElementById(this.wrapID + 'yesDefinitelyWriteAnalyzer').checked

            if(allowed)
                document.getElementById(this.wrapID + 'writeToAnalyzer').removeAttribute('disabled');
            else
                document.getElementById(this.wrapID + 'writeToAnalyzer').setAttribute('disabled', true);
        }

        this.toggleODBwrite = function(){
            //toggle odb writing permission.

            var allowed = document.getElementById(this.wrapID + 'yesDefinitelyWriteODB').checked

            if(allowed)
                document.getElementById(this.wrapID + 'writeToODB').removeAttribute('disabled');
            else
                document.getElementById(this.wrapID + 'writeToODB').setAttribute('disabled', true);
        }

        this.toggleAllODBWrites = function(){
            // make each channel's odb write toggle match the master switch

            var toggles = document.getElementsByClassName('write-to-odb'),
                master = document.getElementById('writeAllChannels'),
                state = master.checked,
                i;

            for(i=0; i<toggles.length; i++){
                toggles[i].checked = state;
            }

        }

    }
</script>
