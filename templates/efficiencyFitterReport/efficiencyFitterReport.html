<link rel="stylesheet" href="efficiencyFitterReport.css"/>

<template id='efficiencyFitterReport'>
    <div class='sectionWrapper item'>
        <div class='col-md-12'>
            <table id='{{id}}efficiencyFitterResults' class='table efficiencyFitterTable'></table>

            <button type="button" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myAnalyzerModal">
                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write calibration to Analyzer
            </button>
<br>
            <button type="button" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myODBModal">
                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write calibration to ODB
            </button>
<br>
            <button type="button" class="btn btn-primary btn-lg"  id='saveCal'>
                <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Save Cal file
            </button>
	    <input id='saveCalname' type='text' value='GRIFFIN-Cal-File.cal' width='500px'></input>

        </div>
    </div>

    <!--are you sure modal for Analyzer write-->
    <div class="modal fade" id="myAnalyzerModal" tabindex="-1" role="dialog" aria-labelledby="myAnalyzerModalLabel">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                    <h4 class="modal-title" id="myAnalyzerModalLabel">Change values in Analyzer Config file?</h4>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to change the quadratic, gain and offset values for all selected detectors in the Analyzer? There is no undo.</p>
                    <input type='checkbox' id='{{id}}yesDefinitelyWriteAnalyzer'></input>
                    <label for='{{id}}yesDefinitelyWriteAnalyzer'>I'm very sure.</label>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal" id='dismissAnalyzermodal'>
                        <span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span> Abort
                    </button>
                    <button type="button" class="btn btn-default" id='{{id}}writeToAnalyzer' disabled>
                        <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write
                    </button>
                </div>
            </div>
        </div>
    </div>
	
    <!--are you sure modal for ODB write-->
    <div class="modal fade" id="myODBModal" tabindex="-1" role="dialog" aria-labelledby="myODBModalLabel">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                    <h4 class="modal-title" id="myODBModalLabel">Change values in ODB?</h4>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to change the quadratic, gain and offset values for all selected detectors in the ODB? There is no undo.</p>
                    <input type='checkbox' id='{{id}}yesDefinitelyWriteODB'></input>
                    <label for='{{id}}yesDefinitelyWriteODB'>I'm very sure.</label>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal" id='dismissODBmodal'>
                        <span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span> Abort
                    </button>
                    <button type="button" class="btn btn-default" id='{{id}}writeToODB' disabled>
                        <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span> Write
                    </button>
                </div>
            </div>
        </div>
    </div>
</template>

<script>
    function efficiencyFitterReport(wrapID){

        this.wrapID = wrapID;
        this.wrap = document.getElementById(wrapID);

        this.setup = function(){
            // build list of source titles
    var listOfSourceTitles = [];
    
    if(dataStore.THESEdetectors[0].includes('PAC')){
     var thisObject = {
                         "name" : dataStore.sourceInfoPACES[0].name,
                         "title" : dataStore.sourceInfoPACES[0].title
                      }
       listOfSourceTitles.push(thisObject);
    }else{
	    for(var i=0; i<dataStore.sourceInfo.length; i++){
	        var thisObject = {
		                    "name" : dataStore.sourceInfo[i].name,
		                    "title" : dataStore.sourceInfo[i].title
	                         }
	        listOfSourceTitles.push(thisObject);
	    }
    }
    
            //inject templates
            this.wrap.innerHTML = Mustache.to_html(
                dataStore.templates.efficiencyFitterReport, 
                {
                    'id': this.wrapID, 
                }
            );
            // table has to be done as a separate template, since templates and tables don't play too nice together
console.log('Inject the Table');
    // Build the list of rows for the table. Loop through each peak of each source
    var detectors =[];
    var keys = Object.keys(dataStore.sourceInfo);
    for(i=0; i<keys.length; i++){
      for(j=0; j<dataStore.sourceInfo[keys[i]].literaturePeaks.length; j++){
        detectors.push(keys[i] + '-P' + j);
      }
    }
    console.log(keys); 
    console.log(detectors);
    document.getElementById(this.wrapID + 'efficiencyFitterResults').innerHTML= Mustache.to_html(
                dataStore.templates.efficiencyFitterReportTable, 
                content = {
                    'id': this.wrapID, 
                    'detectors': detectors
                }
            );

            //make sure the file name for Cal file download gets passed around:
             document.getElementById('saveCalname').onchange = function(){
            //set the filename to whatever the user has requested:
             document.getElementById('saveCal').download = this.value;
            }

            // Set up the Cal file button 
            document.getElementById('saveCal').onclick = function(){ buildCalfile(); }

            //set up fit callbacks
            dataStore.viewers[dataStore.plots[0]].fitCallback = this.fitCallback.bind(this);

            //plug in the allow Analyzer write switch
            document.getElementById(this.wrapID + 'yesDefinitelyWriteAnalyzer').onchange = this.toggleAnalyzerwrite.bind(this);

            //plug in write to Analyzer button
            document.getElementById(this.wrapID + 'writeToAnalyzer').onclick = function(){
                //bail out if there's no fit yet
                if(Object.keys(dataStore.fitResults).length == 0){
                    window.alert('You need to perform the gain match (see button at top of page) before writing results to the Analyzer.');
                    document.getElementById('dismissAnalyzermodal').click();
                }
                updateAnalyzer();
            }

            //plug in the allow ODB write switch
            document.getElementById(this.wrapID + 'yesDefinitelyWriteODB').onchange = this.toggleODBwrite.bind(this);

            //plug in write to odb button
            document.getElementById(this.wrapID + 'writeToODB').onclick = function(){
                //bail out if there's no fit yet
                if(Object.keys(dataStore.fitResults).length == 0){
                    window.alert('You need to perform the gain match (see button at top of page) before writing results to the ODB.');
                    document.getElementById('dismissODBmodal').click();
                }
                promiseScript(dataStore.ODBrequests[0]);
            }
        },

        this.fitAllSinglesPeaks = function(){
            //fit all spectra to the peaks defined.
            //this: efficiencyFitterReport object
            console.log(dataStore);

            // Change rawData to another list that is just the Sum_Energy_ spectrum
            var i, keys = Object.keys(dataStore.spectrumListSingles),
                buffer = dataStore.currentPlot //keep track of whatever was originally plotted so we can return to it

            releaser(
                function(i){
                    // Change rawData to another list that is just the Sum_Energy_ spectrum
                    var keys = Object.keys(dataStore.spectrumListSingles);
                    this.fitSpectra(keys[i])
                }.bind(this),

                function(){
                    var evt;
                    //set up fit line re-drawing
                    dataStore.viewers[dataStore.plots[0]].drawCallback = this.addFitLines;

                    //comunicate with the user
                    if(document.getElementById('pickerMessage')){ deleteNode('pickerMessage') }
                    document.getElementById('reviewMessage').classList.remove('hidden');

                    //leave the viewer pointing at the first spectrum for fitting
                    dispatcher({target: buffer}, 'fitAllComplete')

                    // Message to console
                    console.log('fitAllSinglesPeaks releaser has finished its work. Now have all peaks fitted for singles spectra.'); 

                    dataStore.sourceInfo['133Ba'].normalizationFactor = this.normalizeSourceData('133Ba','152Eu'); 
                    dataStore.sourceInfo['56Co'].normalizationFactor = this.normalizeSourceData('56Co','152Eu');

for(i=0; i<dataStore.sourceInfo['133Ba'].rawEfficiency.length; i++){
dataStore.sourceInfo['133Ba'].normalizedEfficiency.push((dataStore.sourceInfo['133Ba'].rawEfficiency[i]*dataStore.sourceInfo['133Ba'].normalizationFactor).toFixed(2)); 
}
for(i=0; i<dataStore.sourceInfo['56Co'].rawEfficiency.length; i++){
dataStore.sourceInfo['56Co'].normalizedEfficiency.push((dataStore.sourceInfo['56Co'].rawEfficiency[i]*dataStore.sourceInfo['56Co'].normalizationFactor).toFixed(2)); 
}
dataStore.sourceInfo['152Eu'].normalizedEfficiency = dataStore.sourceInfo['152Eu'].rawEfficiency; 
console.log(dataStore.sourceInfo['133Ba'].normalizedEfficiency); 
console.log(dataStore.sourceInfo['152Eu'].normalizedEfficiency); 
console.log(dataStore.sourceInfo['56Co'].normalizedEfficiency);

            //update the relative efficiency data plot which includes all sources
            this.reconstructRelativeEfficiencyData();

console.log(dataStore);

                }.bind(this),

                keys.length-1
            )
        },

this.normalizeSourceData = function(thisSourceKey,referenceSourceKey){
// The data for thisSourceKey will be normalized to the data of the referenceSourceKey
// returns the best-fit normalization factor

if(thisSourceKey == '133Ba' && referenceSourceKey == '152Eu'){
console.log('normalizing 133Ba to 152Eu:');

// take only some of the points
var referenceSourceKeyData = dataStore.sourceInfo[referenceSourceKey].rawEfficiency.slice(1,3);
var thisSourceKeyData = dataStore.sourceInfo[thisSourceKey].rawEfficiency.slice(1,4);
}

if(thisSourceKey == '56Co' && referenceSourceKey == '152Eu'){
console.log('normalizing 56Co to 152Eu:');

// take only some of the points
var referenceSourceKeyData = dataStore.sourceInfo[referenceSourceKey].rawEfficiency.slice(6,8);
var thisSourceKeyData = dataStore.sourceInfo[thisSourceKey].rawEfficiency.slice(0,4);
}

var referenceSourceKeyAverage = (referenceSourceKeyData.reduce((a, b) => parseFloat(a) + parseFloat(b), 0))/referenceSourceKeyData.length; 
var thisSourceKeyAverage = (thisSourceKeyData.reduce((a, b) => parseFloat(a) + parseFloat(b), 0))/thisSourceKeyData.length;

console.log(referenceSourceKeyData); 
console.log(thisSourceKeyData); 
console.log(referenceSourceKeyData.length); 
console.log(thisSourceKeyData.length); 
console.log(referenceSourceKeyAverage); 
console.log(thisSourceKeyAverage);

normalizationFactor = referenceSourceKeyAverage / thisSourceKeyAverage;

console.log(normalizationFactor);

return [normalizationFactor];
}

        this.fitAllSummingCorrections = function(){
            //fit all spectra to the peaks defined.
            //this: efficiencyFitterReport object
            console.log(dataStore);

            var i, keys = Object.keys(dataStore.rawData),
                buffer = dataStore.currentPlot //keep track of whatever was originally plotted so we can return to it

            releaser(
                function(i){
                   var keys = Object.keys(dataStore.rawData);
                    this.fitSpectra(keys[i])
                 //   document.getElementById('progress').setAttribute('style', 'width:' + (100*(keys.length - i) / keys.length) + '%' )   
                }.bind(this),

                function(){
                    var evt;
                    //set up fit line re-drawing
                    dataStore.viewers[dataStore.plots[0]].drawCallback = this.addFitLines;

                    //comunicate with the user
                    if(document.getElementById('pickerMessage')){ deleteNode('pickerMessage') }
                    document.getElementById('reviewMessage').classList.remove('hidden');

                    //leave the viewer pointing at the first spectrum for fitting
                    dispatcher({target: buffer}, 'fitAllComplete')

                }.bind(this),

                keys.length-1
            )
        },

        this.fitSpectra = function(spectrum){
            //redo the fits for the named spectrum.
            //<spectrum>: string; name of spectrum, per names from analyzer
            //this: efficiencyFitterReport object

            var viewerName = dataStore.plots[0];

            // Set the current Source for this spectrum
            dataStore.currentSource = Object.keys(dataStore.sourceInfo).find(key => dataStore.sourceInfo[key].histoFileName.split('.')[0] === spectrum.split(':')[0])
            console.log('fitSpectra for '+spectrum+', identify key '+dataStore.currentSource);

            //set up fitting for this spectrum/source
            dataStore.viewers[viewerName].addData(spectrum, JSON.parse(JSON.stringify(dataStore.rawData[spectrum])) );
            dataStore.currentPlot = spectrum;
            dataStore.viewers[viewerName].plotData() //kludge to update limits, could be nicer
            dataStore.viewers[viewerName].fitTarget = spectrum;
            dataStore._plotListLite.exclusivePlot(spectrum, dataStore.viewers[dataStore.plots[0]]);

            // Loop through all literature peaks for this source
            for(i=0; i<dataStore.sourceInfo[dataStore.currentSource].literaturePeaks.length; i++){

            //set up peak fit
            dataStore.currentPeak = i;
            dataStore.viewers[viewerName].FitLimitLower = dataStore.ROI[dataStore.currentSource][dataStore.currentPeak][0];
            dataStore.viewers[viewerName].FitLimitUpper = dataStore.ROI[dataStore.currentSource][dataStore.currentPeak][1];
            dataStore.viewers[viewerName].fitData(spectrum, 0);
            }

            //dump data so it doesn't stack up 
            dataStore.viewers[viewerName].removeData(spectrum); 
        },

        this.addFitLines = function(){
            //add current fits to the plot
console.log('addFitLines in efficiencyFitterReport');

            var fitLines = [];
            var lower, upper, middle
                viewerName = dataStore.plots[0];

            dataStore.viewers[viewerName].containerFit.removeAllChildren();

            // Set the current Source for this spectrum
            dataStore.currentSource = Object.keys(dataStore.sourceInfo).find(key => dataStore.sourceInfo[key].histoFileName === dataStore.currentPlot.split(':')[0])
            console.log('fitSpectra for '+dataStore.currentPlot+', identify key '+dataStore.currentSource);

            for(i=0; i<dataStore.sourceInfo[dataStore.currentSource].literaturePeaks.length; i++){
            //add fit lines
            fitLines[i] = dataStore.viewers[viewerName].addFitLine(
                        dataStore.ROI[dataStore.currentSource][i][0], 
                        dataStore.ROI[dataStore.currentSource][i][1] - dataStore.ROI[dataStore.currentSource][i][0], 
                        dataStore.fitResults[dataStore.currentPlot][i][0], 
                        dataStore.fitResults[dataStore.currentPlot][i][1], 
                        dataStore.fitResults[dataStore.currentPlot][i][2], 
                        dataStore.fitResults[dataStore.currentPlot][i][3], 
                        dataStore.fitResults[dataStore.currentPlot][i][4]
                    );

             dataStore.viewers[viewerName].containerFit.addChild(fitLines[i]);
            }

            dataStore.viewers[viewerName].stage.update();
        },

        this.fitCallback = function(center, width, amplitude, intercept, slope){
            //after fitting, log the fit results, as well as any modification made to the ROI by the fitting algortihm
            //also update table
            //<center>: number; center of gaussian peak
            //<width>: number; width of peak
            //<amplitude>: number; amplitude of peak
            //<intercept>: number; intercept of linear background beneath peak
            //<slope>: number; slope of linear background
            //this: gainMatchReport object

            var lowPeak = document.getElementById('fitLow'); 
            var midPeak = document.getElementById('fitMid'); 
            var highPeak = document.getElementById('fitHigh'); 
            var vhiPeak = document.getElementById('fitvHi');
            var viewerName = dataStore.plots[0];

            // update the progress bar
            dataStore.progressBarPeaksFitted++;
         console.log('Fitted '+dataStore.progressBarPeaksFitted+' of '+dataStore.progressBarNumberPeaks+' peaks.');
            document.getElementById('progress').setAttribute('style', 'width:' + (100*(dataStore.progressBarPeaksFitted / dataStore.progressBarNumberPeaks)) + '%' );   

            if(!dataStore.fitResults[dataStore.currentPlot])
                dataStore.fitResults[dataStore.currentPlot] = [];

            //keep track of fit results
            dataStore.fitResults[dataStore.currentPlot][dataStore.currentPeak] = [amplitude, center, width, intercept, slope]

            //convenient to arrange resolution data here
            dataStore.sourceInfo[dataStore.currentSource].FWHM[dataStore.currentPeak] = (width*2.35).toFixed(2);

            // Update the ROI in case they were modified by the fitting routine
            dataStore.ROI[dataStore.currentSource][dataStore.currentPeak][0] = dataStore.viewers[viewerName].FitLimitLower;
            dataStore.ROI[dataStore.currentSource][dataStore.currentPeak][1] = dataStore.viewers[viewerName].FitLimitUpper;  


            // Calculate peak area here
            var grossArea = 0,
                netArea = 0,
                integral = 0,
                functionVals = [],
                i, x, sigmas = 5, stepSize = 0.01;
            //calculate peak area in excess of background, for <sigmas> up and down.
            for(i=0; i<2*sigmas*width/stepSize; i++){
                x = center - sigmas*width + i*stepSize
                functionVals.push( gauss(amplitude, center, width, x)*stepSize )
                integral = functionVals.integrate()
            }
            dataStore.sourceInfo[dataStore.currentSource].uncorrectedArea[dataStore.currentPeak] = integral.toFixed(0);
            console.log(dataStore.currentPlot + ', '+dataStore.currentSource + ', Peak '+dataStore.currentPeak+', centroid='+center.toFixed(2)+', height='+amplitude.toFixed(2)+', FWHM='+(width*2.35).toFixed(2)+', Net Area = '+dataStore.sourceInfo[dataStore.currentSource].uncorrectedArea[dataStore.currentPeak]);

            //update table
            this.updateTable(dataStore.currentPlot);

            //update data plots for the individual sources
            this.reconstructSourceEfficiencyData();

return;

            //disengage fit mode buttons
            if( parseInt(lowPeak.getAttribute('engaged'),10) == 1)
                lowPeak.onclick(); 
            if( parseInt(midPeak.getAttribute('engaged'),10) == 1)
                midPeak.onclick(); 
            if( parseInt(highPeak.getAttribute('engaged'),10) == 1)
                highPeak.onclick(); 
            if( parseInt(vhiPeak.getAttribute('engaged'),10) == 1)
                vhiPeak.onclick();

        },

        this.updateTable = function(spectrum){
            //update the report table with whatever is currently in the dataStore
            //recall dataStore.fitResults[plotTitle] = [[amplitude, center, width, slope, intercept],[...]], for [low energy, high energy].
            //<spectrumName>: string; name of spectrum, per names from analyzer
            //this: efficiencyFitterReport object

            var calibration, thisID;

            // define the ID for the HTML elements
            thisID = this.wrapID + dataStore.currentSource + '-P' + dataStore.currentPeak;
console.log('updateTable for '+thisID);

// Update the literature parts of the table
           if(dataStore.currentPeak == 0)
            document.getElementById(thisID+ 'title').innerHTML = dataStore.sourceInfo[dataStore.currentSource].title; 
            document.getElementById(thisID+ 'energy').innerHTML = dataStore.sourceInfo[dataStore.currentSource].literaturePeaks[dataStore.currentPeak]; 
            document.getElementById(thisID+ 'intensity').innerHTML = dataStore.sourceInfo[dataStore.currentSource].literatureIntensity[dataStore.currentPeak]+'('+dataStore.sourceInfo[dataStore.currentSource].literatureIntensityUnc[dataStore.currentPeak]+')'; 

// update the measured and calculated items in the table
            if(dataStore.sourceInfo[dataStore.currentSource].FWHM[dataStore.currentPeak])
                document.getElementById(thisID+ 'FWHM').innerHTML = dataStore.sourceInfo[dataStore.currentSource].FWHM[dataStore.currentPeak]; 
            if(dataStore.sourceInfo[dataStore.currentSource].uncorrectedArea[dataStore.currentPeak]){
                document.getElementById(thisID+'uncorrectedArea').innerHTML =
dataStore.sourceInfo[dataStore.currentSource].uncorrectedArea[dataStore.currentPeak]+'('+Math.sqrt(dataStore.sourceInfo[dataStore.currentSource].uncorrectedArea[dataStore.currentPeak]).toFixed(0)+')';

// Calculate the raw efficiency here
dataStore.sourceInfo[dataStore.currentSource].rawEfficiency[dataStore.currentPeak] = (dataStore.sourceInfo[dataStore.currentSource].uncorrectedArea[dataStore.currentPeak]/dataStore.sourceInfo[dataStore.currentSource].literatureIntensity[dataStore.currentPeak]).toFixed(2);

// Display in the table as a placeholder before summing corrections are done.
document.getElementById(thisID+'relativeEfficiency').innerHTML = dataStore.sourceInfo[dataStore.currentSource].rawEfficiency[dataStore.currentPeak];
}

        },

        this.calculateLine = function(lowBin, highBin){
            //given the positions of the low bin and high bin, return [intercept, slope] defining
            //a striaght calibration line using the energies reported in the input.
            //lowBin: number; center of low energy peak in bins
            //highBin: number; center of high energy peak in bins
            //this: gainMatchReport object

            var lowEnergy = document.getElementById('peak1').value
            var highEnergy = document.getElementById('peak2').value
            var slope, intercept;

            slope = (lowEnergy - highEnergy) / (lowBin - highBin);
            intercept = lowEnergy - slope*lowBin

            return [intercept, slope]

        },

        this.fitEfficiencyCurve = function(Xdata,Ydata){
            //given the x and y data, fit an 8th order polynomial as the efficiency curve
            // Xdata and Ydata are arrays containing the X and the Y data points. X is energy, Y is counts/efficiency
            //this: efficiencyCurveReport object

//            var quad, slope, intercept;
            var data = [];

    //Convert to log and convert keV to MeV
     for(var i=0; i<Xdata.length; i++){
       data.push([Math.log(Xdata[i]/1000), Math.log(Ydata[i])]);
     }

// Hats off to Tom Alexander, https://github.com/Tom-Alexander/regression-js
const result = regression.polynomial(data, { order: 8, precision: 20 }); 
console.log(result);

           return result.equation;

        },

        this.reconstructSourceEfficiencyData = function(){
            // First determine the residuals by applying the calibration coefficients to the fitted centroid, then comparing it to the literature energy.
            // Save the residuals data to the dataStore, then
            //arrange the latest residual info for representation in the dygraph.

// Find the plot id for this source
var thisPlotID = dataStore.efficiencyPlotDataKeyMap.indexOf(dataStore.currentSource);
console.log('reconstructEfficiencyData for Plot'+thisPlotID); 
console.log(dataStore.currentSource); 
console.log(dataStore.currentPeak); 
console.log();

// Fill the flags array
               var flags = [];
flags.fillN(0, dataStore.sourceInfo[dataStore.currentSource].literaturePeaks.length);

             // x value should be the literature energy value
             // How do we add x values to the dataplot? - Answer is you pass them to arrangePoints function.
 
             // y value of raw efficiency plot is the uncorrected area divided by intensity
             dataStore.efficiencyPlotData[thisPlotID][dataStore.currentPeak] = dataStore.sourceInfo[dataStore.currentSource].rawEfficiency[dataStore.currentPeak];


               // Update the Y axis scale if needed
               if(dataStore.efficiencyPlotData[thisPlotID][dataStore.currentPeak] < (0.75 * dataStore.YAxisMinValue[thisPlotID][0])){
                 dataStore.YAxisMinValue[thisPlotID][0] = dataStore.efficiencyPlotData[thisPlotID][dataStore.currentPeak] * 1.33; 
               }
               if(dataStore.efficiencyPlotData[thisPlotID][dataStore.currentPeak] > (0.75 * dataStore.YAxisMaxValue[thisPlotID][0])){
                 dataStore.YAxisMaxValue[thisPlotID][0] = dataStore.efficiencyPlotData[thisPlotID][dataStore.currentPeak] * 1.33; 
               }

               dataStore.dataplotData[thisPlotID] = arrangePoints(dataStore.sourceInfo[dataStore.currentSource].literaturePeaks, [dataStore.efficiencyPlotData[thisPlotID]], flags );
               var eventString = 'updateDyData'+thisPlotID;
               dispatcher({ 'data': dataStore.dataplotData[thisPlotID] }, eventString);
            

        },

        this.reconstructRelativeEfficiencyData = function(){
            // First determine the residuals by applying the calibration coefficients to the fitted centroid, then comparing it to the literature energy.
            // Save the residuals data to the dataStore, then
            //arrange the latest residual info for representation in the dygraph.

// Find the plot id for this source
var thisPlotID = 1;
console.log('Relative Efficiency plot data for plot'+thisPlotID);

// The peak energies over all sources are not sequential. So build an
// object of the peak energies and efficienicies so we can
// then sort them into energy order before displaying the plot.
             // x value should be the literature energy value
             // y value is raw efficiency normalized to 152Eu

var data = [];

    // loop over all sources
    var count=0;
    var keys = Object.keys(dataStore.sourceInfo);
    for(var i=0; i<keys.length; i++){
for(var j=0; j<dataStore.sourceInfo[keys[i]].literaturePeaks.length; j++){
if(isNaN(dataStore.sourceInfo[keys[i]].normalizedEfficiency[j]) || !dataStore.sourceInfo[keys[i]].normalizedEfficiency[j]){ continue; } 
data.push({
'X' : dataStore.sourceInfo[keys[i]].literaturePeaks[j],
   'Y' :dataStore.sourceInfo[keys[i]].normalizedEfficiency[j]
});
}
}

    // Order the x and y arrays in energy order 
data.sort( compareX );

// Fill the arrays with the energy-sorted data
    for(var i=0; i<data.length; i++){
dataStore.efficiencyPlotXData[thisPlotID].push( data[i].X ); 
dataStore.efficiencyPlotData[thisPlotID].push( data[i].Y );
}


            // Fit the relative efficiency curve
            // Make array of log and log values
            // use regression with 8th order polynomial
            // Plot the curve
            dataStore.efficiencyPlotEquationParameters[1] = this.fitEfficiencyCurve(dataStore.efficiencyPlotXData[1], dataStore.efficiencyPlotData[1]);

            // Build the relative efficiency curve data from the fitted parameters
var params = dataStore.efficiencyPlotEquationParameters[1];
params = params.reverse();
console.log(params);

// Hard code to a GEANT4 efficiency curve for testing and development
// crystalUSSDSSnodescantfullshields1614.50
//params = [ -2.4731527545,-0.6159638309 , 0.0152499594 ,-0.0901066898 ,-0.0392021262 , 0.0195202734 , 0.0053811928 ,-0.0017085412 ,-0.0004470462  ]; 
//for(i=0; i<10000; i+=5){
    for(var i=0; i<dataStore.efficiencyPlotXData[thisPlotID].length; i++){
var thisX = dataStore.efficiencyPlotXData[thisPlotID][i];

// HPGeEfficiency() expects energy in MeV and the natural log.
dataStore.efficiencyPlotY2Data[thisPlotID][i] = HPGeEfficiency(params, Math.log(parseFloat(thisX/1000)));
console.log('Calculated efficiency of '+dataStore.efficiencyPlotY2Data[thisPlotID][i]+' for energy '+thisX);
}

// Fill the flags array
               var flags = [];
flags.fillN(0, dataStore.efficiencyPlotXData[thisPlotID].length);


               // Update the Y axis scale if needed
               if(dataStore.efficiencyPlotData[thisPlotID][dataStore.efficiencyPlotData.length-1] < (0.75 * dataStore.YAxisMinValue[thisPlotID][0])){
                 dataStore.YAxisMinValue[thisPlotID][0] = dataStore.efficiencyPlotData[thisPlotID][dataStore.efficiencyPlotData.length-1] * 1.33; 
               }
               if(dataStore.efficiencyPlotData[thisPlotID][0] > (0.75 * dataStore.YAxisMaxValue[thisPlotID][0])){
                 dataStore.YAxisMaxValue[thisPlotID][0] = dataStore.efficiencyPlotData[thisPlotID][0] * 1.33; 
               }

               dataStore.dataplotData[thisPlotID] = arrangePoints(dataStore.efficiencyPlotXData[thisPlotID], [dataStore.efficiencyPlotData[thisPlotID], dataStore.efficiencyPlotY2Data[thisPlotID]], flags );
               var eventString = 'updateDyData'+thisPlotID;
               dispatcher({ 'data': dataStore.dataplotData[thisPlotID] }, eventString);
            
        },

        this.reconstructMidasResidualsData = function(currentSpectrum,currentDetNum){
            // First determine the residuals by applying the calibration coefficients from the server to the fitted centroid, then comparing it to the literature energy.
            // Save the residuals data to the dataStore, then
            //arrange the latest residual info for representation in the dygraph.

             var thisOffset = dataStore.midasCalibration[currentSpectrum][0]; 
             var thisGain = dataStore.midasCalibration[currentSpectrum][1]; 
             var thisQuadratic = dataStore.midasCalibration[currentSpectrum][2];

             for(currentPeak=0; currentPeak<4; currentPeak++){
               var peakIndex = currentPeak+1;
               var literatureEnergy = document.getElementById('peak'+peakIndex).value; 
               peakIndex +=4;

               // Save the data for the residuals plots
               thisCentroid = dataStore.fitResults[currentSpectrum][currentPeak][1];
               dataStore.residualsData[peakIndex][currentDetNum] = literatureEnergy - ( thisOffset  + (thisGain*thisCentroid) + (thisQuadratic*thisCentroid*thisCentroid) );

               var i, evt, detectorIndex = [],
               flags = [];
               flags.fillN(0, dataStore.THESEdetectors.length)

               for(i=0; i<dataStore.THESEdetectors.length; i++){
                  detectorIndex[i] = i;
               }

               // Update the Y axis scale if needed
               if(dataStore.residualsData[peakIndex][currentDetNum] < (0.75 * dataStore.YAxisMinValue[peakIndex][0])){
                 var newYAxisMinValue = dataStore.residualsData[peakIndex][currentDetNum] * 1.33; 
                 dataStore.YAxisMinValue[5][0] = dataStore.YAxisMinValue[6][0] = dataStore.YAxisMinValue[7][0] = dataStore.YAxisMinValue[8][0] = newYAxisMinValue;
               }
               if(dataStore.residualsData[peakIndex][currentDetNum] > (0.75 * dataStore.YAxisMaxValue[peakIndex][0])){
                 var newYAxisMaxValue = dataStore.residualsData[peakIndex][currentDetNum] * 1.33; 
                 dataStore.YAxisMaxValue[5][0] = dataStore.YAxisMaxValue[6][0] = dataStore.YAxisMaxValue[7][0] = dataStore.YAxisMaxValue[8][0] = newYAxisMaxValue;
               }

               dataStore.dataplotData[peakIndex] = arrangePoints(detectorIndex, [dataStore.residualsData[peakIndex]], flags );
               var eventString = 'updateDyData'+peakIndex;
               dispatcher({ 'data': dataStore.dataplotData[peakIndex] }, eventString);
            }

            // Update the mean and standard deviation of the dataset
            this.calculateMidasResidualsSD();
        },

        this.calculateResidualsSD = function(){
            //identifies the mean and SD of the residuals across all detectors

            var i, meanP1 = 0, sqMeanP1 = 0, meanP2 = 0, sqMeanP2 = 0, meanP3 = 0, sqMeanP3 = 0, meanP4 = 0, sqMeanP4 = 0,
                numP1 = 0, numP2 = 0, numP3 = 0, numP4 = 0;

            for(i=0; i<dataStore.residualsData.length; i++){
                if(dataStore.residualsData[1][i]){
                    meanP1 += dataStore.residualsData[1][i]; 
                    sqMeanP1 += Math.pow(dataStore.residualsData[1][i],2);
                    numP1++;
                }
                if(dataStore.residualsData[2][i]){
                    meanP2 += dataStore.residualsData[2][i]; 
                    sqMeanP2 += Math.pow(dataStore.residualsData[2][i],2);
                    numP2++;
                }
                if(dataStore.residualsData[3][i]){
                    meanP3 += dataStore.residualsData[3][i]; 
                    sqMeanP3 += Math.pow(dataStore.residualsData[3][i],2);
                    numP3++;
                }
                if(dataStore.residualsData[4][i]){
                    meanP4 += dataStore.residualsData[4][i]; 
                    sqMeanP4 += Math.pow(dataStore.residualsData[4][i],2);
                    numP4++;
                }
            }

            meanP1 /= numP1; 
            meanP2 /= numP2; 
            meanP3 /= numP3; 
            meanP4 /= numP4;

            sqMeanP1 /= numP1; 
            sqMeanP2 /= numP2; 
            sqMeanP3 /= numP3; 
            sqMeanP4 /= numP4;


            sdMeanP1 = Math.sqrt(sqMeanP1 - Math.pow(meanP1,2)); 
            sdMeanP2 = Math.sqrt(sqMeanP2 - Math.pow(meanP2,2)); 
            sdMeanP3 = Math.sqrt(sqMeanP3 - Math.pow(meanP3,2)); 
            sdMeanP4 = Math.sqrt(sqMeanP4 - Math.pow(meanP4,2)); 

            dataStore.residualsDataMean = [0, meanP1, meanP2, meanP3, meanP4]; 
            dataStore.residualsDataSD = [0, sqMeanP1, sqMeanP2, sqMeanP3, sqMeanP4];

            document.getElementById('residualP1newText').innerHTML  = 'Peak1 residuals: Mean: '+meanP1.toFixed(3)+', Standard Deviation: '+sdMeanP1.toFixed(3)+' keV'; 
            document.getElementById('residualP2newText').innerHTML  = 'Peak2 residuals: Mean: '+meanP2.toFixed(3)+', Standard Deviation: '+sdMeanP2.toFixed(3)+' keV'; 
            document.getElementById('residualP3newText').innerHTML  = 'Peak3 residuals: Mean: '+meanP3.toFixed(3)+', Standard Deviation: '+sdMeanP3.toFixed(3)+' keV'; 
            document.getElementById('residualP4newText').innerHTML  = 'Peak4 residuals: Mean: '+meanP4.toFixed(3)+', Standard Deviation: '+sdMeanP4.toFixed(3)+' keV';
        },

        this.calculateMidasResidualsSD = function(){
            //identifies the mean and SD of the residuals across all detectors

            var i, meanP1 = 0, sqMeanP1 = 0, meanP2 = 0, sqMeanP2 = 0, meanP3 = 0, sqMeanP3 = 0, meanP4 = 0, sqMeanP4 = 0,
                numP1 = 0, numP2 = 0, numP3 = 0, numP4 = 0;

            for(i=0; i<dataStore.residualsData.length; i++){
                if(dataStore.residualsData[5][i]){
                    meanP1 += dataStore.residualsData[5][i]; 
                    sqMeanP1 += Math.pow(dataStore.residualsData[5][i],2);
                    numP1++;
                }
                if(dataStore.residualsData[6][i]){
                    meanP2 += dataStore.residualsData[6][i]; 
                    sqMeanP2 += Math.pow(dataStore.residualsData[6][i],2);
                    numP2++;
                }
                if(dataStore.residualsData[7][i]){
                    meanP3 += dataStore.residualsData[7][i]; 
                    sqMeanP3 += Math.pow(dataStore.residualsData[7][i],2);
                    numP3++;
                }
                if(dataStore.residualsData[8][i]){
                    meanP4 += dataStore.residualsData[8][i]; 
                    sqMeanP4 += Math.pow(dataStore.residualsData[8][i],2);
                    numP4++;
                }
            }

            meanP1 /= numP1; 
            meanP2 /= numP2; 
            meanP3 /= numP3; 
            meanP4 /= numP4;

            sqMeanP1 /= numP1; 
            sqMeanP2 /= numP2; 
            sqMeanP3 /= numP3; 
            sqMeanP4 /= numP4;


            sdMeanP1 = Math.sqrt(sqMeanP1 - Math.pow(meanP1,2)); 
            sdMeanP2 = Math.sqrt(sqMeanP2 - Math.pow(meanP2,2)); 
            sdMeanP3 = Math.sqrt(sqMeanP3 - Math.pow(meanP3,2)); 
            sdMeanP4 = Math.sqrt(sqMeanP4 - Math.pow(meanP4,2)); 

            dataStore.residualsDataMean = [0, meanP1, meanP2, meanP3, meanP4]; 
            dataStore.residualsDataSD = [0, sqMeanP1, sqMeanP2, sqMeanP3, sqMeanP4];

            document.getElementById('residualP1midText').innerHTML  = 'Peak1 residuals: Mean: '+meanP1.toFixed(3)+', Standard Deviation: '+sdMeanP1.toFixed(3)+' keV'; 
            document.getElementById('residualP2midText').innerHTML  = 'Peak2 residuals: Mean: '+meanP2.toFixed(3)+', Standard Deviation: '+sdMeanP2.toFixed(3)+' keV'; 
            document.getElementById('residualP3midText').innerHTML  = 'Peak3 residuals: Mean: '+meanP3.toFixed(3)+', Standard Deviation: '+sdMeanP3.toFixed(3)+' keV'; 
            document.getElementById('residualP4midText').innerHTML  = 'Peak4 residuals: Mean: '+meanP4.toFixed(3)+', Standard Deviation: '+sdMeanP4.toFixed(3)+' keV';
        },

        this.updateEnergies = function(){
            //callback for the calibration source dropdown; updates energy input boxes with standard values
            //this: gainMatchReport object

            var calibrationSourceName = getSelected(this.wrapID + 'calibrationSource');

            // Find the index number for the source information for this sourceType
            var index = dataStore.sourceInfo.map(function(e) { return e.name; }).indexOf(calibrationSourceName);

            // Set the peak energies for this source
            document.getElementById('peak1').value  = dataStore.sourceInfo[index].lowEnergy;
            document.getElementById('peak2').value  = dataStore.sourceInfo[index].midEnergy;
            document.getElementById('peak3').value = dataStore.sourceInfo[index].highEnergy;
            document.getElementById('peak4').value  = dataStore.sourceInfo[index].vhiEnergy;

        },

        this.customEnergy = function(){
            //callback for changing the calibration energies to custom values
            //this: gainMatchReport object

            var i, keys = Object.keys(dataStore.fitResults)
            var defaultSources = document.getElementById(this.wrapID + 'calibrationSource')

            defaultSources.value = 'custom'
        },

        this.toggleFitMode = function(){
            //gain matcher needs special fit controls for convenience
            //this: fit mode engage button element

            var viewerName = dataStore.plots[0];

            if(parseInt(this.getAttribute('engaged'),10) == 0){
                dataStore.viewers[viewerName].setupFitMode();
                this.setAttribute('engaged', 1); 
                if(this.id == 'fitLow')
                    document.getElementById('refitLoBadge').classList.add('red-text') 
                if(this.id == 'fitMid')
                    document.getElementById('refitMidBadge').classList.add('red-text') 
                if(this.id == 'fitHigh')
                    document.getElementById('refitHiBadge').classList.add('red-text') 
                if(this.id == 'fitvHi')
                    document.getElementById('refitvHiBadge').classList.add('red-text')
            }
            else{
                dataStore.viewers[viewerName].leaveFitMode();
                this.setAttribute('engaged', 0);
                if(this.id == 'fitLow')
                    document.getElementById('refitLoBadge').classList.remove('red-text') 
                if(this.id == 'fitMid')
                    document.getElementById('refitMidBadge').classList.remove('red-text') 
                if(this.id == 'fitHigh')
                    document.getElementById('refitHiBadge').classList.remove('red-text') 
                if(this.id == 'fitvHi')
                    document.getElementById('refitvHiBadge').classList.remove('red-text')
            }

            if(this.id == 'fitLow')
                dataStore.currentPeak = 0
            else if(this.id == 'fitMid') 
                dataStore.currentPeak = 1
             else if(this.id == 'fitHigh')
                dataStore.currentPeak = 2
            else
                dataStore.currentPeak = 3

        },

        this.toggleAnalyzerwrite = function(){
            //toggle Analyzer writing permission.

            var allowed = document.getElementById(this.wrapID + 'yesDefinitelyWriteAnalyzer').checked

            if(allowed)
                document.getElementById(this.wrapID + 'writeToAnalyzer').removeAttribute('disabled');
            else
                document.getElementById(this.wrapID + 'writeToAnalyzer').setAttribute('disabled', true);
        }

        this.toggleODBwrite = function(){
            //toggle odb writing permission.

            var allowed = document.getElementById(this.wrapID + 'yesDefinitelyWriteODB').checked

            if(allowed)
                document.getElementById(this.wrapID + 'writeToODB').removeAttribute('disabled');
            else
                document.getElementById(this.wrapID + 'writeToODB').setAttribute('disabled', true);
        }

        this.toggleAllODBWrites = function(){
            // make each channel's odb write toggle match the master switch

            var toggles = document.getElementsByClassName('write-to-odb'),
                master = document.getElementById('writeAllChannels'),
                state = master.checked,
                i;

            for(i=0; i<toggles.length; i++){
                toggles[i].checked = state;
            }

        }

    }
</script>




